 

							                         以这个类为例		
                                                                   public class person{

                                                                          String name;//可以对成员变量直接初始化
												  int age;    //如 String name ="小明";
		 										  String sex;
                                                                     
										   }	

一 、类与对象的定义
1. 类：具有同一种特征的事物的集合
2.对象：类中的一个具体个体

二、类与对象的创建
1.类的创建：以intell idea为例 
  点击scr -> 新建 -> Java类 -> 输入类的名称->创建成功

实际上 我们用的Main.java 就是一种类
而下面的public static void main(String[] args ) {}
就是一种方法
我们创建对象甚至可以 Main.p=new Main();
       方法也可以在Main类中创建，不过要创建在Main类与main方法之间
  

2.对象的创建：
对象的引用就是对象的地址
 在main中 使用关键字new + 类名（）；就可以创建一个对象了
 类名称 + 对象名（引用类型变量名称）=new 类名称（）；  //除了基本类型，就是引用类型 String也是引用类型
如 person p1=new person();
  person p2=new person();

p1 p2 都相当于 一 个指针
p1 p2 指向他们对应的对象

对象可以创建多个，每个对象都是独立的
  p1与p2是两个独立的对象

如果person p1=new person();
      person p2=p1;
  这样的话p1 与p2 都指向同一个对象了
注意：不是p1 p2都等于对象本身，而是储存了对象的引用（地址），而不是对象的复制,
           总之理解为  p1 p2 都指向同一个对象
---------------------------------------------------------------------------------------------------------------------------
重点：
引用类型变量 储存的都是对应对象的地址，比如可以打印一下引用类型变量，虽然不是打印出来的不是地址（因为toString方法是并不是打印地址），但绝对不是对象本身

public class Main {
    public static void main(String[] args) {
       person p;//如果我们只是声明了一个Person对象，但是并没有去创建对应的对象实例（new),Person p;//这里会给个 64bit 的内存储存p
       p=null;//这里将引用类型变量p的值（地址）是指向的一个特殊的空对象（null object），这个空对象的所有字段都初始化为默认值，而不是64个0
       p=new person(185,18);//这里用new创建了一个实例对象，然后返回对应的地址给p
	 p.age=20;//通过p所储存的地址来找到它所储存的对象的age，并修改为20
	 p.high=200.5//通过p所储存的地址来找到它所储存的对象的high,并修改为200.5

    }这样 p就有了一个非null地址，来储存实例对象
    public static class person{
        double high;//8个字节 64bit
        int age;//4个字节 32bit
        person(double high,int age){
            this.age =age;
            this.high=high;
        }
    }
}
我们可以看到，p对象中数据大小是96个bit，即12个字节，但是我们的地址只有8个字节，为什么呢？

地址和数据大小是两码事！！！

所有引用类型变量储存的其实是指向对象的地址(指针),而基本数据类型变量的地址就是它对应数据内容的二进制编码

数据和内存都是储存在计算机的内存中，但是他们储存的形式是不一样的，数据指计算中需要进行处理的信息，可以是文件数字图像视频之类的，
而内存是计算机用于储存和读取这些数据的物理设备，在内存中，数据被转换从二进制形式，通过地址来进行访问。内存单元是内存中最小的储存单元，每个内存单元都有唯一的地址，可以用来储存和读取数据，因此可以说数据内存是储存在内存单元中

数据内存是储存在内存单元里面的，每个内存单元都有唯一的地址，可以用来储存和读取数据。

而地址是用来定位内存中数据所在位置的。程序在执行过程中会根据变量对应的地址来访问内存并获取或修改变量的值
因此*地址不是储存数据的单元*，而是来寻址内存单元的，实际上，数据是储存在内存单元中的，每个内存单元都有唯一的地址标识，通过地址就可以找到相应的内存单元并读取里面储存的数据

地址字节数：
java的引用相当于c++的指针,C++的指针是占四个字节，java引用应该也是固定的大小。
java里面所有引用类型变量储存的都是64地址，而不是对象的内存数据
（c++里面地址是4个字节，java里面64位机是8个字节，即64bit）

a=b
就是把a的bit 复制成b的bit

——————————————————————————————————————————————————————————————————————————————————————————

三、对象的使用
1.在main 中可以通过 对象名.类成员属性 就可以使用对象了
如    p.name="小明"；
    p.age=18；

    特别的，当p指向的是null，就操作不了了
   比如  person p=null;
这样会显示  NullPointerException 空指针异常

另外 如果不对成员变量初始化，那么成员变量会根据类型自动赋值
如 int -> 0
boolean -> flase
String -> null（引用类型都为null）


四、方法的创建与使用
1.方法 ：类似于函数
2.方法的创建: 与函数一样创建





返回类型 + 方法名+（ 参数）{

           方法体

}

例如 int sum(int a,int b){
     
     return a+b;
}

3.方法的使用:

实际上 我们用的Main.java 就是一种类
而下面的public static void main(String[] args ) {}
就是一种方法
我们创建对象甚至可以 Main.p=new Main();
       方法也可以在Main类中创建，不过要创建在Main类与main方法之间
  

使用与函数的使用类似，不过有点区别
只有对象才能够使用方法
 如      方法：对象名.sum(3，4)；
      函数：sum(3,4);

五、方法的进阶使用

1.this的用法:

	当出现多个名称重复时，可以使用this关键字
比如:
	public class person{

     String name;
     int age;    
     String sex;   

	void setname(String name){
        name=name;

    }                                                             
}	

这里的方法是用让对象的的name属性更改为我们输入的字符串,但两个都叫name,计算机分辨不出来,所以我们可以用this关键字，如下
public class person{

     String name;
     int age;    
     String sex;   

	void setname(String name){
        this.name=name;

    }

}
这样我们就可以知道前一个name是对象的一个属性了
   this 表示我们当前创建的对象


2.方法的重载：
构造方法，静态方法可以重载，

定义：在同一个类中同名的方法可以存在多个
只要它的参数列表里 类型，数量，顺序有不同就可以，返回类型和修饰符一不一样无所谓


public class person{

     String name;
     int age;    
     String sex;   

	int sum(int a,int b){
      return a+b;
      }
    
      double sum(double a, double b){
      return a+b;
      }

}
像这样sum方法就有两个了，使用的时候，系统会根据你输入的参数来判断你用的是哪一种

我们使用的print()方法实际上就是有方法重载，这样我们才可以打印不同类型的内容

3.方法调用方法

	方法可以调用别的方法，也可以调用本身，调用本身就叫递归

方法调用一定要有个停止条件，不然会栈溢出


如 int hello(){

return hello()

}



六、构造方法:
1.构造方法的创建：
写在类中，

类名 （）{

} 注意不需要返回类型（void都没有），可以有参数，也可以没有参数  方法名与类名相同

实际上在反编译的时候会自动生成一个没有参数的构造方法，可以在点开out中的类来看


如 person (){
   name="小明";
   age=18;  //构造方法的内容会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行，当然也可以在创建成员变量时就初始化
   sex="男";
}

2.构造方法的使用：

构造方法也可以重载

同样它也需要一个对象来使用

比如在main中

person p=new person();//实际上这里就是在调用无参数构造方法
这时 构造方法的内容已经执行了
这时p.name="小明“；



当然我们也可以写个有参数的调用方法


如 person (string name,int age,String sex){
   this.name=name;
    this.age=age;
   this.sex=sex;	
}


main中调用时：
person p=new person(”小明“，18，”男“)；//要写参数，就像调用方法一样


如果我们写了带参数的，会覆盖掉原来自带的没有参数的，我们可以通过重载，再写一个没有参数的


注意如果这样，不仅在构造方法中对成员变量初始化
                      且在成员变量创建时就初始化了


public class person{

     String name=”未知“;
     int age=10;    
     String sex=”女“;   

{  
     内容  } //代码块

	person（）{

  }
     person(String name){
      this.name=name
}
}
在创建对象时，从上往下执行
代码块不管是在构造方法前还是后，都比构造方法先执行

当在main中new 的是无参的构造方法时，有参数的构造方法就不会执行
new 的是有参数的构造方法时，才会执行
且类会从上往下执行，遇到可以执行的就会执行



七、静态方法和静态变量（又叫类方法和类变量，因为属于类)

用关键字 static
静态属性可以被对象访问，也可以直接被类范围

所以的对象都可以对同一个static 变量进行操作，就像 一 群人 一起画一幅画，都可以对画进行创作

可以用对象访问静态属性，也可以直接用 类.静态属性 来访问

创建的一个类中：在静态属性中不能使用任何成员属性(变量，方法)和this，this也是属于对象的
只能使用静态属性

代码块也可以静态化

public class person{

     String name;
     int age;    
     String sex;   
     static info; 
}


这样这样被static标记 的方法和变量，都可以被所有对象使用
换句话说，静态方法和变量是所有对象共享的（操作的都是同一个东西）；


成员属性属于对象，静态属性属于类
   静态属性 可以通过    类名.静态属性来访问



.class文件是给jvm去执行的，而每一个.class文件就是类，
java中使用一个类之前，jvm不会在一开始就去加载它，而是在用到的时候就会去加载类：


1.访问静态变量，或者为静态变量赋值,调用静态方法
2.new 创建类的对象（隐式加载）
3.子类初始化
4.其他


***所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前就完成加载

即 在创建对象时先执行类中的静态内容 再成员内容

**创建的一个类中：在静态属性中不能使用任何成员属性(变量，方法)和this，this也是属于对象的
只能使用静态属性

**在main方法中：
可以直接使用Main类中的静态方法，也可以通过创建对象来使用Main类中的非static方法和static方法

可以通过创建对象来，使用非Main类中的方法（静态和非静态），也可以直接通过 类名.静态方法来使用非Main类中的静态方法

八、包声明与导入
1.包：
包就是可以对类进行分类，用于存放类或者包
格式： com.b包名
包的创建：
scr->新建->软件包->输入格式->创建成功
不仅如此，你还可以在包中创建包

注意：可以将类移动到包中，不过如果将类放到包中，要在类的最上面添加关键字package来指明当前类所处于的包，如package com.text;
（一定要与目录中的包名一 一对应）

****不同的类可以放在不同的包下，不同包中的类，就算类名相同，也是不同的类

2.包的导入
当我们要使用同一级包中的类时直接使用即可，而当我们需要使用其他包中的类时就需要导入了

使用关键字：import com.包名.类名
当然我们使用的类在不同的包下时才导入，如果一个包中有多个类，可以使用    import.包名.*;   来将包中的类全部导入  ，也可以一个一个导入，*表示这个包中所有的类

实际上我们使用的System类，也是与Main在一个包中的 在java.lang；

而java.lang 这个类会自动导入，这就是为什么我们使用System.out.println();不需要导入java.lang.System了

 当然你也可以导入，不过这样多此一举了
  import java.lang.System 





-----——————————————
九、访问权限控制

java中引入了访问权限控制（可见性），我们可以为成员变量，成员方法，静态变量，静态方法甚至是类拉力指定访问权限，不同的访问权限，有着不同程度的访问限制，要在权限内才可以导入类，或其他内容


private:私有，标记为私有的内容无法被当前类以外的任何位置访问

什么都不写：默认，默认情况下，只能被类本身和同包中的其他类访问

protect:受保护，标记为受保护的内容，可以被类本身和同包中的其他类访问，也可以被子类访问

public:公共，标记为公共的内容，允许在任何地方被访问




我们可以把类前面的public 去掉，变为默认的，但不允许变为protect和pravite
因为，我们定义出来的普通类，要么是给自己所在的包用，要么给外面的都要，如果pravite，那么只有自己类本身可以用，protect,只有同包类和不同包的子类 和本身可以用,那么定义出来干嘛


3.静态属性的导入

之前我们学到，静态属性是属于类的，我们要访问它可以直接用类名.静态属性
当然这一切都要在有访问权限的时候才可以


我们使用静态属性，除了用类名.静态属性
还可以用静态导入的方法，直接将类中的静态属性导入到我们要用的类中，当然也需要有访问权限

 静态导入： 导入可以这样： import static com.包名.类名.静态属性

导入后我们可以就可以直接使用静态属性了，而不需要 类.静态属性

——————————————————————————————————————————————————————————————
十、类的封装

1. 把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口（方法之类的）
 保证变量的安全性，如果不封装，类中的实例（成员）变量，可以直接修改，这样不太好，所以编写类时，一般将成员private，外部类需要使用Getter和Setter方法来查看改变和设置变量

比如在person类中 ：

private String name;

并且在下方设置接口，

public String getName(){
  return name;
}
这样才能在外部类中访问name属性

如果想要在外部类中修改类的成员属性，这时需要在类中设定几个方法（修改成员属性的）
然后在外部类中调用这些方法，从而达到修改成员属性的目的


如在内部类中设置方法

public void settername(String name){
this.name=name;
}
这样 之后在外部类中调用这个函数
settername("小明");
这样name就被修改为了小明

不仅如此，你也可以在内部类中写一个创建对象的方法
然后再外部类中调用这个方法，来获取一个新的对象
比如：
 public student newstudent(){
        return new student(); 
    }


十一、类的继承（关键字extends）

1.在定义不同类时，会有一些共同的属性，这些属性我们可以把他单独抽象成一个父类，定义子类可以继承该父类
从而减少代码的重复定义
比如 Person 类就是一个父类，而Student，Worker是他的子类，都有Person的特征


2.创建一个子类：
与创建类一样操作，当创建完成时，我们要写在他要继承什么父类
比如
public class Worker extends Person{

}
在开头的那一行用关键字extends + 继承的父类名  从而继承成功
注意，只能继承一个类，不过可以一路往下

继承成功之后，子类可以直接访问到父类中的属性（变量和方法（静态的或者非静态的都可以））（除了权限为private的）


创建一个子类对象，与之前的相同，
类名 +变量名=new 类名（）；
如 Student student=new Student();

3. 如果父类中的构造函数是有参构造，那么子类的构造方法也必须要用相应的有参构造
如 Student（String name, int age,String sex）{
	super(name,age,sex);//必须这么写，在这个方法里的这句话的前面不允许出现其他语句
}
这里是子类构造方法调用了父类的构造方法
注意super()表示父类 （超类） 

在写完super(name,age,sex);之前不能写任何其他的语句
比如：这么写是错的
   public Student(String name,int age,String sex){
        int a;//super（）之前不允许出现任何语句
        super(name,age,sex);
    }

4.子类可以当成父类用
比如 Person person =new Student();  == Person person=new Person();
可以这样，但是如果这样写，
person 只能使用Person中的属性（只要权限够），不能使用Student中的属性（向上转型）（不过本质上还是Student类型的，只是当成了Person类来用）//但是调用重写过的方法是用new 后面的类里重写过的方法（特例）
举个更具体的例子：
Student 继承 Perosn 类，Student里的属性仅仅比Person多一个 int id=123;
我们用Student来创建一个Person的对象
Person p=new Student("小明",18,"男");
这样我们可以发现，p.id 是不存在的，就是说这样写并不能访问到Student里的属性，只能是Person里的属性

不过：
当然还可以用强制类型转化，将person转化成 Student 类型
这样：Person p= new Student("小明",18,"男");
        Student p2=(Student) p ;//强制类型转换
这样就可以了，不过只能强制转化为他本来的类型，这里就不能转化为Worker类的


5.关键字 instanceof
可以对一个对象的类型进行判断
如上面的 person可以怎么写
person instanceof Student 判断person 是否是这个Student true
person instanceof Person  判断person 是否是这个Person   true
student instanceof xiaoStudent (Student 是 xiaoStudent的父类) 结果为false；
所以instanceof 可以判断所引用的对象是对应类型或是对应类型的子类，那么就返回true 否则false
具体的例子：
Person Student xiaoStudent //左边的是右边的父类
有
 Student s=new Student("小红",18,"女");
        if(s instanceof xiaoStudent ) System.out.println("true");
        else System.out.println("false");
结果为：false
Student s=new Student("小红",18,"女");
        if(s instanceof Student ) System.out.println("true");
        else System.out.println("false");
结果为：true
Student s=new Student("小红",18,"女");
        if(s instanceof Person ) System.out.println("true");
        else System.out.println("false");
结果为：true

即 instanceof可以判断 左边（对象）是不是右边（类）的本身或子类，是为true，不是为false

6. 子类是可以定义与父类同名的属性的
比如在Student 类中可以定义一个String name;

当在Student 类中使用name ,用的就是 Student 类中的name(就近原则)
当如果要访问父类中的name 我们可以使用super关键字

7.派生：
子类在继承父类后，可以获取父类所有的非private属性，当然子类也可以生成父类没有的东西，父类不能使用
派生就是子类可以有父类没有的属性

十二、Object类
1.所有类都继承Object 类，只是没有写（默认）
2.Object类里面有很多方法
如：
*hashcode();//返回对象的哈希值

*equals();//判断两个对象是否相等，
（Obejct里的并没有重写，是所有equals方法的初始形式）
 public boolean equals(Object obj) {
        return (this == obj);//这种没有重写的equals方法比较的是两个对象的内存地址是否相同，还是用==来判断的，所以这个方法实际上就等价于  this==obj
    }

这里没有重写的equals方法 等价于 ==  （都是看两个对象的内存地址是否相等）

但是有些类里面重写了equals方法，如String类里的equals() 
  public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }//这里面比较的是两个对象的内容，内容相同就true，不同就false


所以如果比较两个字符串（是用new 来创建的，而不是直接 =” 字符串“）是否相同，不能使用==，而是用equals()  它本身就重写了euqals()

	  String s1=new String("hello");//字符串对象只能是用new方式创建的
        String s2=new String("hello");
        System.out.println(s1.equals(s2) );
结果为true

但是基于String类的特性
如果是直接用=” “来创建的，那么实际上只要内容是一样的它们两个就是同一个对象
	  String s1="hello";
        String s2="hello";//基于String的特性，s1与s2是同一个对象（内存地址相同）
        System.out.println(s1==s2 );
	  System.out.println(s1.equals(s2));//不过用==还是用equals()都是true
结果为： true
        true

**以上说了这么多，实际上就可以总结为  ==  与未重写的equals() 比较的是两个对象的内存地址   == 等价于 未重写的equals()
						而重写了的equals() 比较的是两个对象里的内容

另外说一点：重写equals方法时一定要重写hashCode方法
因为：当只重写equals方法，不重写hashCode时，违反规定：equals相等的对象必须具有相等的哈希码（因为hashCode的返回值还是按照Object类的规范：同一对象的hashCode值相同）

每次重写 equals 方法时都必须重写 hashCode 方法，否则程序将无法正常运行。你的 hashCode 方 法必须遵从 Object 类指定的常规约定，并且必须执行合理的工作，将不相等的哈希码分配给不相等的实例。



*clone()//将对象克隆
源码：protected native Object clone() throws CloneNotSupportedException;//这里会抛出个异常，用法在异常那里
//可以看到有个native 表示这是个本地方法，底层由c++编写

这个Object里 的clone()方法不能直接使用，要用必须重写
 protected Object clone()throws CloneNotSupportedException {
       return super.clone(); //Obejct是所有类的最终父类，即所有类最终都继承Obejct
    } 
这里仅仅是浅克隆


*toString()//打印对象的信息

public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
Object里的toString方法依然是所有toString方法的初始状态，可以看到，Object里的toString方法会返回一串奇怪的字符串，里面有hashcode，以及一些其他的

当然我们也可以在我们的类中重写toString方法，
如：
  @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex='" + sex + '\'' +
                '}';
    }
这样我们就可以打印出对象的信息了，也可以写成其他的形式

在后面的集合类里，我们可以直接System.out.println(集合对象); 打印出集合对象里的元素，是因为，我们实际上就是调用了集合类里重写过的toString方法

3.**Obejct可以接收其它引用类型的对象
如：
Object object=new Person();  //其实就是上面说的，子类当作父类来使用，实际上等价于 Object object=new Object();
同意也支持类型转换，向上转型


**注意：除了以上介绍的方法，Object类里面还有一些其他的方法（是关于多线程和反射的），这里不讲，详情在多线程和反射
**由于所有的类最终都是继承Obejct,所以基于继承的特性，所有的类都可以有Obejct类里的方法

————————————————————————————————
十三、方法的重写
1.方法的重写与重载不同，方法的重写是将已经有的方法给他改变重新编写新的内容，编写后新的内容会覆盖掉老的方法，
静态方法不能被重写，但可以被重载
用@Override 
 + 要重写的方法 来表示你要重写 （其实可以不加@Override，系统会自动检测你有没有重写，@Override这个其实是注解，表示重写）

**注意：重写方法要与原来的方法完全一致（名字，返回类型，参数）
无论多少级都可以重写，（父类的父类方法也可以）因为是一层一层继承下来的

2.对于子类重写父类的方法，重写后的权限必须大于等于父类的权限，但是如果父类的权限为private，那么就不能重写了，因为
子类不能访问到父类的这个方法，只能算是子类的一种方法了

//注意子类重写父类的方法，那么重写后的方法只能是子类或子类的子类（如果子类的子类没重写方法）来使用
父类只能使用本身的方法，不能使用子类重写过的方法

3.一个方法可以重写多次，使用这些重写方法，看你对象的类型的什么（new 后面的那个类型），就会调用那个类里面的重写方法
例子：  Person p=new Person();
        Student s=new Student();//注意这里
        Person xs=new Student();//注意这里

        p.test();
        s.test();
        xs.test();
结果为：
我是人类
我是学生
我是学生

Person Student xiaoStudent 左边是右边的父类
子类都重写了父类的test方法
test里写的分别是 我是人类 我是学生 我是小学生
后面两个调用的都是Student里的test方法，不管它前面的类型是什么，调用的都是new 后面那个类型里的test方法，

第三个这与之前说的继承，子类当作父类用不太一样（对象只能使用父类的对象），它调用的并不是Person里的test方法，而是new后面的类里的方法，
但是只是调用重写的方法这一点不太一样，其他的也与之前说的一样（子类当父类来用（只能用前面的类型的东西））
** 这是特例


4.基于这种重写的特性，（一个类有多个子类）对一个类定义的行为，不同的子类可以有不同的行为，比如考试，学生考试可以得到A,工人只能得到D，（不同的子类对于同一个方法可能会出现不同的结果，这其实就是多态的体现）

5.如果不希望子类重写某个方法，那么可以在这个方法前加上final关键字，表示这个方法已经是最终形态，但是可以重载

同样 在类中的变量属性前加final 这样，这个属性只能在构造方法中改变一次，之后就无法在更改，
如果在类的名称前在final,那么这个类就不能被继承


同样，当我们重写父类方法时，如果希望调用父类方法原本的方法实现，那么同样可以使用super关键字来使用父类的东西(不过只能在那个重写方法里用)
**super和this一样也不能再静态方法中使用     super关键字只能在重写方法，或者是继承父类的子类参构造方法里使用
***********
现在我们来看一下重写和重载的区别：
1.定义不同---重载是定义相同的方法名，参数不同；重写是子类重写父类的方法。

2.范围不同---重载是在一个类中，重写是子类与父类之间的。

3.多态不同---重载是编译时的多态性，重写是运行时的多态性。

4.返回不同---重载对返回类型没有要求，而重写要求返回类型，有兼容的返回类型。

5.参数不同---重载的参数个数、参数类型、参数顺序可以不同，而重写父子方法参数必须相同。

6.修饰不同---重载对访问修饰没有特殊要求，重写访问修饰符的限制一定要大于被重写方法的访问修饰符。

重写equals()必须也要重写hashcode方法，理由见Obejct类那里


————————————————————————————————
十四、抽象类（abstract）
抽象类的特点就是可以有抽象方法
1.就是在父类中只给你一个抽象的方法（没有方法体），只让你知道有这个方法，然后在子类中具体实现，在子类中用方法重写来具体实现这个方法

比如 Person类有个talk 的方法
     可以创建 chinese,japanse这些子类，在这些子类中，我可以分别重写talk方法，chinese就在重写talk方法中写说中文的具体,japanse就在重写方法中写说日语的具体

例如：在Person类中定义一个抽象方法，然后在子类Student Worker 中重写这个抽象方法，使之具体化

比如：
public abstract class Person {//这是一个抽象类
    String name;
    int age;
    String sex;
    abstract void talk();//这是抽象方法
}

2.关键字
  abstract 在类前面加个abstract 表示这个类是抽象类，可以具有抽象方法，当然也可以有具体方法

当一个类有了抽象方法后，他的子类必须要重写抽象方法，如果抽象类有抽象方法没有在子类中具体实现
那么不能创建这个子类的对象
比如：
public class Student extends Person{

}
Student里面并没有实现Person的抽象方法talk()；
所以会报错，所以就不能创建Student的对象

在方法前加abstract表示抽象方法，抽象类不能创建对象，就是这种模式 new 抽象类();
 Person p=new Person();//这里会报错

**//注意这样其实后面学的匿名内部类可以解决这个问题
比如：Person p=new Person() {//这里用了匿名内部类
            @Override
            void talk() {
                System.out.println("我是中文");
            }
        };
        

另外：抽象类的抽象方法不能为private不然不能重写



————————————————————————————————————————————————————————
十五、接口 （interface）
1.与抽象类类似，但比抽象类更抽象，甚至算不算一种类，它是对功能的抽象（抽象方法的集合），比如Person有个学习的功能，我们可以把这个功能写成一个接口（接口中都是的方法都是抽象方法），然后Person的子类就可以继承这个接口（要在子类中重写），不同的子类就分别重写对应的抽象方法。
2.关键字：interface 表示这是一个接口
public interface Study {//将interface改为class的话，又会变成一个普通类
    
}

如 Public interface Study{ 表示一个接口，里面只能写抽象方法，也可以有
	public abstract void study（）；//这个就是个抽象方法，public 和 abstract 可以省略，因为默认就是这个,而且只能写这个
} 

3.关键字 ：implements 实现接口
在 类+implements+接口，接口 表示这个类可以使用（实现）这个接口（可以连多个接口，用逗号 隔开）
如：Public class Student extends Person implements Study
，如果接口中有抽象方法（有几个就要重写几个），那么在类中必须重写这个抽象方法，来具体实现


4.接口与抽象类一样，不能直接创建对象，但是我们可以将接口实现类的对象一接口的形式去使用

比如： 一接口Study 一个类 Student（实现了Study）
Study study =new Student();//前提是Student中实现了Study接口中的方法，（向上转型）

当然也可以强制类型转换
Student student=(Student) study;

这是study只能使用Study中的属性（还有Object中的东西），而不能使用Student中的属性（但还是Student类型的）

5.一个类可以 实现多个接口（不能说是多继承，不太一样），但只能继承一个父类

6.从java开始，接口中可以存在方法的默认实现
用关键字 default

Public interface Study{ 
	void study（）；

	default void test(){/这个就是一个默认实现，要有方法体，不是抽象方法，在子类中可以不写方法重                    				     写，但也可以重写（注意如果在重写时要调用原来接口中的那个方法，那么要加关键字super,如Study.super.text();）
	System.out.println("hello");
  }
} 

7.接口不同于类 ，不能存在成员方法和变量，但是可以存在静态变量和静态方法（属于接口，可以通过接口来访问（接口.静态属性））


但 在接口中 定义的变量只能是 public static final 的（默认为这样，可以省略）（不能修改值）
                               方法只能是 public static       


8.Object 中的Cloneable方法（必须要实现接口才能使用）javaSE,P45最后

9.接口可以继承接口（多个）

有接口A与B，一个类test
A继承（extends）B,test实现A
则，test要向实现A,要把A和B中的抽象方法全部重写
如果A和B接口中出现了同名的抽象方法，那么子接口会覆盖父接口的抽象方法

如果接口中的抽象方法与Object中的方法相同，那么就不用在类中实现，因为已经实现了（但是也可以重写）


有接口A，类test1，test2
test2继承（extends）test1 ,test2实现接口A
test1中有接口A中抽象方法的实现，那么，test2就不用再重写写A对接口A的方法实现了
如果A接口中的（default）默认实现（有方法体）再test1中也有相应的方法实现，那么，test1中的方法实现会覆盖A接口中的默认实现

特别的：接口中不能有Object类中的默认方法（其实也没有必要，因为Object中本身就有），要写就必须写对应的抽象方法

十六、枚举类enum 
1.
public enum Status {   //enum表示这是一个枚举类，枚举类的语法稍微有一些不一样
    RUNNING, STUDY, SLEEP;    //直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上
}

**枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量：
所以每一个枚举常量都可以直接通过枚举类来使用  枚举类.枚举常量

***
既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：
public enum Status {
    RUNNING("睡觉"), STUDY("学习"), SLEEP("睡觉");   //无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法）

    private final String name;    //枚举的成员变量
    Status(String name){    //覆盖原有构造方法（默认private，只能内部使用！）
        this.name = name;
    }

    public String getName() {   //获取封装的成员变量
        return name;
    }
}
————————————————————————————
十七、基本类型包装类
1.
包装类层次：
			Object

      Character    Number   Boolean(继承bter->Object类)


   Byte      Short    Integer   Float    Double (这一行继承Number类)
其中能够表示数字的基本类型包装类，继承自Number类

byte->Byte
boolean->Boolean
short->Short
char->Character
int->Integer
long->Long
float->Float
double->Double

右边的都属于基本类型类（继承Number类），左边是基本类型

可以直接使用
如： Integer i =new Integer(10);(Integer的构造方法中这么写的)

这里的 i 实际是一个对象（Integer型）
包装类实际上是我们的基本数据类型被封装成了一个类（有封装的思想），内部会有操作

小知识：true 00000001
-------------------------------------
2.自动装箱机制：（将基本类型，变为包装类）
包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值
所以上面也可以直接这样写：
Integer i=10;
实际上等价于（隐式调用了这个方法Integer.valueOf） Integer i=Integer.valueOf(10);
只是为了简化代码，才直接这样Integer i=10;写

这是怎么做到的？为什么一个对象类型的值可以直接接收一个基本类类型的值？实际上这里就是自动装箱：
public static void main(String[] args) {
    Integer i = Integer.valueOf(10);    //上面的写法跟这里是等价的
}
这里本质上就是被自动包装成了一个Integer类型的对象，只是语法上为了简单，就支持像这样编写
-------------------------------
既然能装箱，也是支持拆箱的：
3.自动拆箱机制：(将包装类，变为基本类型)
Integer i=10;
int a=i;

这里的 int a=i; 实际上是等价于 int a=i.intValue(); 通过此方法变成基本类型int值
									同样也是为了简洁代码，只写i

------------------------------
4.包装类和基本类型可以一起运算
得益于包装类的知道装箱和拆箱，我们可以让包装类和基本类型一起运算

如：Integer a=10,b=20;
int c= a*b;
这里c的值就为200

----------------------------
5.包装类型对象的等价：

这里是手动申请两个对象
Integer a=new Integer(10);
Integer b=new Integer(10);
这里new 两个为10 的Integer 型对象a,b
因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的

如果用 a==b 来判断相不相等，会显示false
但是用a.equals(b); 则会显示true
因为equals在Integer里重写了
内容如下：
  public boolean equals(Object obj) {
        if (obj instanceof Integer) {
            return value == ((Integer)obj).intValue();
        }
        return false;
    }
只要值相同它们就相等



用new的方式来得到两个包装类对象，是两个不同的对象
---------————————
但是如果a,b都用自动装箱来申请的话，结果不一样了
Integer a=10,b=10;//这里实际上a与b是同一一个对象
如果用 a==b 来判断相不相等，会显示true，说明内存地址相同是同一个对象
但是用a.equals(b); 则会显示true，说明值相同

***理由如下：

其实关键在省略了的 Integer.valueOf()；中：
这里面有个缓存机制 （cache）:在-128到127所有值中，会预先创建好对象，当输入的值在这个区间当中时，会在创建好的对象中取，从而用这个值所创建的所有对象其实都是同一个，如果这个值超出了这个范围，那么就不同了。这是因为这些数字常用，为了省内存所以这么写。
注意：不仅Integer 中有， 在Long,Short,Byte的包装类中也有类似的缓存机制 
（所以在 整数类型包装类中 -128-127  只要数字相同，那么它们就是同一个对象，超过就是不同的对象）

--------------------------------------------------------------------
6.Integer包装类中提供的字符串直接转化方法：
注意字符串只能是对应的纯数字或者加上对应的进制符号（0x 0）,如果出现普通的字母，那么会报异常
----------------
String 转 Integer：

*Integer.valueOf()方法
 使用Integer.valueOf()方法，可以将字符串里的数字，直接变为Integer型的十进制
例如：
String str="666";
Integer i=Integer.valueOf(str);
这样i就为666了（这个方法可以应用在leetcode二进制求和中）

注意另外：integer.parseInt()也可以有同样的作用


*Integer.decode()方法（Integer里的静态方法）
将字符串里的16进制转成10进制，8进制转成10进制

 Integer i=Integer.decode("0x10");//16进制转10进制
 System.out.println(i);//结果为16

 Integer i=Integer.decode("077");//8进制转10进制
 System.out.println(i);这样i 就为63了
---------------
Integer转String
*Integer.toHexString(int a);//参数的int ，返回值为String
 这个方法可以将10进制数（int）转16进制数的字符串

   System.out.println("0x"+Integer.toHexString(16));
      结果为0x10

   String i=Integer.toHexString(16);
   System.out.println(i);//结果为10
其实还可以这样：
String[] arr=valueOf(int x);//可以将整数x转换为字符串

----------------------------
注意 ：Character ，Boolean也支持转换（对应的valueOf方法）
-----------------------------
不仅这些，还有很多其他的一些方法
比如： Integer.MAX_VALUE(); Integer包装类的最大整数
	Integer.MIN_VALUE(); Integer包装类的最小整数

其他的就不列出了
————————————————————————————————

十七、特殊包装类：这里将介绍几种特殊的 基本类型包装类（Void, BigInteger, BigDecimal）
------------------------------------------
1.void 类型也有对应的包装类 Void （首字母大写）

使用跟 Integer等类似，但它不能new 
比如 Void v=new Void（）;这种写法是错的
它只能 Void v=null;它只能为null
----------------------------------------------
2.BigInteger 用于计算超大数字的包装类，BigInteger 没有数大小的表示限制，可以表示非常大的数字
注意导入类：import java.math.BigInteger;

使用：
public static void main(String[] args) {
    BigInteger i = BigInteger.valueOf(Long.MAX_VALUE);    //表示Long的最大值，轻轻松松
    System.out.println(i);
}//注意创建一个BigInteger类型的对象一般不用new来赋值 
//而是用valueOf()方法    这个方法里面可以填入数字，或者其他定义好的数字，如Long.MAX_VALUE


我们可以通过调用类中的方法，进行运算操作：

BigInteger i=BigInteger.valueof(100);//用vauleOf来赋值
当然还有它自带的一些写法，
比如BigInteger.ONE（1） BigInteger.TEN（10） 等等
它一般不用new 来赋值。
用BigInteger.valueOf();可以赋值我们想给的任意值

另外注意：
它与Integer不同，BigInteger不支持加减乘除的运算（不支持自动拆箱和装箱），
如果要进行加减乘除，只能用类自带的方法来计算
比如：
multiply()方法
**//注意这个括号里不能直接写数字，而是要用BigInteger.TEN,BigInteger.valueOf(100)之类的来写，
   而且它计算之后的并不是一个值，而是以一个BigInteger包装类对象的形式来返回
如
       BigInteger i= BigInteger.valueOf(100) ;
       i=i.multiply(BigInteger.valueOf(100) );//multiply()返回值是一个对象

**另外：BigInteger的除法和int 一样，不会除出小数

所以一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成


----------------------------------------------
3.BigDecimal 
浮点类型精度有限，对于需要精确计算的场景，就没有办法了，但BigDecimal可以实现小数点的精确计算，

注意：同样要先导入类 import java.math.BigDecimal;

与BigInteger类似，也不能直接new，要用valueOf(); ,实际上所有包装类都是用valueOf();只是那几个基本的包装类可以省略

使用：  BigDecimal i=BigDecimal.valueOf(10) ;
        i=i.divide(BigDecimal.valueOf(3),100,BigDecimal.ROUND_CEILING  ) ;//10/3
	  System.out.println(i);
结果为：3.333333333333333333333333333333333333333333333333333333333333333333（100个）

注意：当计算除法时: 这里BigDecimal.valueOf(3)表示除数，100表示保留几位小数
对于这种结果没有终点的，无限循环的小数，我们必须要限制长度，否则会出现异常。

舍入模式：
BigDecimal.RoundingMode.CEILING 这个表示最后一位的处理方式（向上取整）
BigDecimal.RoundingMode.FLOOR       表示向下取整


小知识：RoundingMode.CEILING，RoundingMode.FLOOR 这其实是枚举类的元素



————————————————————————————————————————————
十八、数组：数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型），其中的每一个数据叫元素
-------------------------------
一维数组：
1.数组的定义：
大部分与c语言相同的用法
int []arry;或者和c语言一样 int arry[]; 但是在Java中不推荐第二种，用第一种

数组类型比较特殊，它本身也是类，引用类型
(继承Object类,所以会有很多Object的方法，如toString，clone ，equals）
-------------------------------
2.数组的创建：
public static void main(String[] args) {
    int[] array = new int[10];   //在创建数组时，需要指定数组长度，也就是可以容纳多个int变量的值
      Object obj = array;   //因为同样是类，肯定是继承自Object的，所以说可以直接向上转型
}				    

数组类型比较特殊，它本身也是类，但是编程不可见（因为底层是C++写的，在运行是动态创建），即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型，所以要创建一个数组要使用new

除了以上的方式创建数组，还有：
类型[] 变量名称 = new 类型[数组大小];
类型 变量名称[] = new 类型[数组大小];  //支持C语言样式，但不推荐！
类型[] 变量名称 = new 类型[]{...};  //静态初始化（直接指定值和大小）
类型[] 变量名称 = {...};   //同上，但是只能在定义时赋值
--------------------------------
3.初始化：

创建时初始化：
可以int [] arry=new int[]{1,2};注意这样写，new 后面的[]里不能有数字
也可以int []arry={1,2,3};
	
如果{}里什么都不写，那么长度默认为0
如果写了大小，没初始化，那么有默认值，引用类型为null,基本类型为0，或false.
（创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的）
-----------------------------
3.访问数组中的元素
int [0]arry;
int[1]arry;
注意，数组的下标是从0开始的，不是从1开始的，所以说第一个元素的下标就是0，我们要访问第一个元素，那么直接输入0就行了，但是注意千万别写成负数或是超出范围了，否则会出现异常。

小知识：public static void main(String[] args) 我们java中的这个String[] args 实际上就是一个数组

我们也可以使用这种方式为数组的元素赋值：
public static void main(String[] args) {
    int[] array = new int[10];
    array[0] = 888;   //就像使用变量一样，是可以放在赋值运算符左边的，我们可以直接给对应下标位置的													元素赋值
    System.out.println("数组的第一个元素为："+array[0]);
}

数组本身也是一个对象，数组对象也是具有属性的，比如长度length

注意：length是在一开始就已经确定的，而且是final类型的，不能修改，也就是说，数组的长度一旦确定，那么不能修改，要用长的数组必须重写创建

当然，既然是类型，那么肯定也是继承自Object类的：
public static void main(String[] args) {
    int[] array = new int[10];
    System.out.println(array.toString());
    System.out.println(array.equals(array));
}
但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现：

所以说通过toString()打印出来的结果，好丑，只不过我们可以发现，数组类型的类名很奇怪，是[开头的。

因此，如果我们要打印整个数组中所有的元素，得一个一个访问：
public static void main(String[] args) {
    int[] array = new int[10];
    for (int i = 0; i < array.length; i++) {
        System.out.print(array[i] + " ");
    }
}


但是有时候为了方便，我们可以使用简化版的for语句foreach语法来遍历数组中的每一个元素：

for语句的简写foreach
实际上形式跟for循环一样,但是（）里的内容不同，
a是数组中值的载体，arr是要循环的数组，会自动循环arr.length次，每次循环后a都会变成对应的元素值
例：
int[] arr={1,3,4,5};

        for (int a:arr) {
            System.out.print(a+” “);
        } 

输出为 1 3 4 5  

这实际是一个语法糖，支持这种写法，但编译出来时，还是我们的for循环
foreach并不是只能用于数组，还可以用于其他，如集合类


**
另外：对于基本类型的数组，并不支持自动装箱和拆箱
比如 int[] arr=new int[10];
Integer[] test=arr;
这样写是错误的，没有这种用法

但可以这样：
Integer[] arr=new Integer[]{1,2,3,4};
实际上是这样：Integer[] arr=new Integer[]{Integer.valueOf(1),2,3,4};
这样是可以自动装箱和拆箱的

还有，由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的：
int[] arr=new int[10];
Object[] array=arr;//这样写是错的
但是如果是引用类型的话，是可以的：
public static void main(String[] args) {
    String[] arr = new String[10];
    Object[] array = arr;    //数组同样支持向上转型
}
public static void main(String[] args) {
    Object[] arr = new Object[10];
    String[] array = (String[]) arr;   //也支持向下转型
}

---------------------------------------------------------------
4. 数组的名称实际上是一个类似指针的东西，为地址，它的值（地址）可以改变
如：
int[] arr=new int[]{1,2,3};
arr=new int[]{4,5,6};
这是arr就是4的地址了，而不是1的地址


————————————————————————————————————————————————
十九、多维数组：实际上就是数组类型的数组
1.final
当基本数据类型加了final 之后，值就不能改变
当引用类型加了final 之后，它本身指向的对象的引用（地址）就不能变
------------------------------------------------
2.多维数组：
int[][] arr;二维数组
前面的int[] 看成一起，就是数组类型的数组

当然还可以创建数组的数组的数组，即三维数组
int[][][] arr;
--------------------------------------------------
3.二维数组：

int[][] arr=new int[2][10];创建了一个2*10的数组

或者：
int[][] arr=new int[][]{{1，2，3，4}，{5，6，7，8}}；这样就创建了2*4的数组
访问和c语言里相同
注意：每个元素（数组）的长度可以不一样（因为是引用来的），比如
int[][] arr=new int[][]{  {0，1，2，3，4}，
			       {5，6，7，8}    }

因为二维数组是元素为数组的数组（二维数组的元素是数组），所以我们可以用一维数组去解释二维数组的元素
比如：
int[][] arr=new int[][]{{1，2，3，4}，{5，6，7，8}}；
int[] a=arr[0];
int[] b=arr[1];
这样 a就是二维数组的第一个数组元素，即a为{1，2，3，4}中1的地址
    b就是第二个数组元素，即b为{5，6，7，8}中5的地址

当然我们这里的二维数组arr储存的仍然是数组型元素的引用（地址），可以改成其他的数组的引用
比如
int[][] arr=new int[][]{{1，2，3，4}，{5，6，7，8}}；

arr[0]=new int[]{0,0,0,0};
这样arr中的元素就变成了{{0，0，0，0}，{5，6，7，8}}
----------------------------------------
遍历arr可以这样写
for(int[] a:arr){//foreach语法糖
    for(int b:a){
        System.out.print(b+” “);
    }
}
结果为0 0 0 0 5 6 7 8 
也可以：
for(int i=0;i<2;i++){
	for(int j=0;j<4；j++){
System.out.print(arr[i][j]);
   }
}

如果二维数组元素（数组）的长度不相同，那么得这样

int[][] arr=new int[][]{{1,2,3,0,0},
                             {4,5,6}};

        for(int i=0;i< arr.length ;i++){//arr.length为二维数组的长度，这里即2
            for(int j=0;j<arr[i].length ;j++){//arr[i].length为元素（数组）的长度，这里即5和3
                System.out.print(arr[i][j]);
            }
        }
结果为12300456

注意：java里面的二维数组与C语言里的二维数组不太一样，
c语言里的二维数组，是一个矩形，每个数组元素的长度是相等的（少了会自动填0）
而java里的二维数组，可以不是矩形，因为每个数组元素的长度可以不一样
如：
int[][] arr=new int[][]{{1,5,3,4,8},{99,55,64}};
arr的长度为2//二维数组的长度
arr[0]的长度为5//第一个数组元素的长度
arr[1]的长度为3//第二个数组元素的长度
-----------------------------------------------------------------------
4.可变长参数：

我们接着来看数组的延伸应用，实际上我们的方法是支持可变长参数的，什么是可变长参数？

就是在编写一个方法时，我们可以在参数类型后加  ...  ，这样就表示这是一个可变长的参数，就是，你在调用这个方法时，你可以填入0到N个这个类型的实际参数，比如
有一个方法：String类型的参数可以写任意个
public static void test(String...str){
    }
那么在调用这个方法时你可以，填入任意个字符串实参，当然也可以不填入参数
test("666","555","444 ","555 ");


那么我们在方法中怎么才能得到这些传入的参数呢，实际上可变长参数本质就是一个数组
例子：
public class Main {
    public static void main(String[] args) {
        test("hello","world ","hello");
    }
    public static void test(String... str){//test方法参数为可变长参数，可以填入0-N个String型的
        for(String s:str){//用foreach 来打印输入的参数
            System.out.println(s);
        }
    }
}

结果为：
hello
world 
hello

------------------
**一个方法中只能有一个可变长参数
如果还有其他类型的参数，那么可变长参数必须放在后面，比如

public static void test(int a,double b,String...str){
	
    }


如何使用填入的实参呢？
其实在这个方法中 这些参数是以对于类型的数组来表示的,你可以这样
例如：
public static void test(String...str){//实际上可变长参数本质就是一个数组
	System.out.println(str[0]);//输出第一个参数
    }



例如：
有一个方法：
public static void test1(int... x){//实际上可变长参数本质就是一个数组
        System.out.println(x[1]);//输出第二个参数
    }
调用这个方法
test1(5,6,7,8,9,4,5,6,1,5,5,5,5,5,5,55,5);
    }
结果为：6

-------------------------------------
这里最后我们再来说一个从开始到现在一直都没有说的东西：
public static void main(String[] args)//这个String[] args到底是个啥？？？
    （用于命令行，javase P52最后）

实际上这个是我们在执行Java程序时，输入的命令行参数，我们可以来打印一下：
public static void main(String[] args) {
    for (String arg : args) {
        System.out.println(arg);
    }
}
可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：
java com/test/Main lbwnb aaaa xxxxx   #放在包中需要携带主类完整路径才能运行
可以看到，我们在后面随意添加的三个参数，都放到数组中了：
lbwnb
aaaa
xxxxx

**这个东西我们作为新手一般也不会用到，只做了解就行了。



——————————————————————————————————————
二十、字符串
1，与c语言相同，java没有字符串基本类型，所以在java中字符串类型是一个引用类型，String是一个类
--------------------------------------------------------
2.java字符串中的字符一旦确定，那么无法进行修改，只能重新创建，
因为在String 类中写了 private final char value[];
------------------------------------------------------------
3.String本身是一个类，不过它比较特殊，创建实例对象时，它可以这样
String str1="hello world";
就是不用new可以直接写，这样的话，这个hello world字符串本身 就是一个对象了

我们也可以象征性地使用一下new关键字：
string str1=new String("hello world");,不过这样冗余了
-------------------------------------------------------------------
4.**注意，如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象：
public static void main(String[] args) {
    String str1 = "Hello World";
    String str2 = "Hello World";
    System.out.println(str1 == str2);
}
结果为：true 说明直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象

**但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了：
public static void main(String[] args) {
    String str1 = new String("Hello World");
    String str2 = new String("Hello World");
    System.out.println(str1 == str2);
}
结果为：false

因此，如果我们仅仅是想要判断两个字符串的*内容是否相同*，不要使用==，用String类重载了equals方法用于判断和比较内容是否相同
-------------------------------------------------------------------------
5.字符串可以相加
也可以 String str="hello"+"world";
        System.out.println(str);//结果为helloworld
两个字符串相加

如果是String str="hello"+new Object();
会自动调用tostring方法 会将后面变为hashcode（类似地址）来拼接
----------------------------------------------------------------------
6.字符串的长度
可以用length 如  str3.length
因为双引号括起来的字符串本身就是一个对象，你也可以，”hello world“.length
--------------------------------------------------------------------
7.字符串自带的方法
1.substring 
可以剪切字符串
有两种 ：字符串也是从0开始
第一种（一个参数的），从这个位置开始切
public class Main {
    public static void main(String[] args) {
        String str = "Hello World";
        String sub = str.substring( 3);   //从3位置分割字符串，并返回一个新的子串对象
        System.out.println(sub);
    }
}
结果为：lo World

第二种（两个参数的），从第一个位置开始到，第二个位置-1
public static void main(String[] args) {
    String str = "Hello World";
    String sub = str.substring(0, 3);   //返回0 到 2 位置的字符串
    System.out.println(sub);
}
结果为：Hel

注意：两种都不支持负数，python支持负数
2.split
可以分割字符串，然后放进一个String数组中
如：
String str=new String("hello world");
String[] s=str.split(" ") ; //将str以空格为分界点分割为若干个子字符串，并变成字符串数组返回
        for(String s1:s){
            System.out.println(s1);
        }
结果为
hello
world


public class Main {
    public static void main(String[] args) {
        String str = "Hello World";
        String[] strings = str.split("l"); //以l为分界线来分割 
        for (String string : strings) {
            System.out.println(string);
        }
    }
}
结果为：可以看到并不会将分割的标志算进去
He

o Wor
d


----------------------------------------------------------------------
8.字符数组和字符串之间是可以相互转化的
如：
字符串转字符数组
String str="hello world";
  char[] chars=str.toCharArray() ;//通过toCharArray()方法来将字符串储存在字符数组中
     
System.out.println(chars);//java中print是支持打印字符数组的（像字符串一样输出）

字符数组转字符串
 char[] chars=new char[]{'奥','里','给'};
        String str=new String(chars);
        System.out.println(str);


当然String 类中还有其他许多方法，
常用的如：
*contains（）(包含)
*toLowerCase()(大写字母转小写字母)
*toUpperCase()（小写转大写）isEmpty()(判断是否为空)
*lastIndexOf()找字符（串）最后出现的位置  charAt()(获取某个位置上的字符)
*compareTo（）和其他字符串进行比较
*startsWith() 是不是以这个字符串开
*endWith() 是不是以这个字符串结尾
*indexof（）找给定字符串的第一次出现的位置，没有返回-1

*replace();可以将字符串给换掉  
String str="hello world";
    String s=str.replace("hello","hi") ;
        System.out.println(s);
结果为：hi world
也可以替换掉一种字符
如
String str="hello world";
    String s=str.replace('l','m') ;
        System.out.println(s);
结果为：
hemmo wormd


注意以上String的方法，返回的是一个全新的字符串，而不是在原来的字符串上改的

------------------------------------------------------------
9.StringBuilding类

**我们在之前的学习中知道了字符串支持+ 和+=来操作
如：
 String str="hello"+"world";
        System.out.println(str);

如果是String str="hello"+new Object();
会自动调用tostring方法 会将后面变为mashcode（类似地址）来拼接

但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：

 String str="hello"+"world";
        System.out.println(str);
两个字符串相加
这在编译后会变成String str="helloworld";（class中）
--------------------------------------------------------
对于变量来说，也有优化，比如下面这种情况：

String str1="你看"；
String str2="这";
String str3="汉堡";
String str4="做的不好";
String result=str1+str2+str3+str4;

编译后 class中仍然是这样的
String str1="你看"；
String str2="这";
String str3="汉堡";
String str4="做的不好";
String result=str1+str2+str3+str4;

如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？这种情况实际上会被优化为下面的写法：

String str1 = "你看";
    String str2 = "这";
    String str3 = "汉堡";
    String str4 = "做滴";
    String str5 = "行不行";
    StringBuilder builder = new StringBuilder();//StringBuilder
    builder.append(str1).append(str2).append(str3).append(str4).append(str5);
    System.out.println(builder.toString());

我们这里可以使用StringBuilding类：专门用于构造字符串，我们可以用它来对字符串进行拼接，就像字符串编辑器，弥补了字符串不能修改的不足


可以像上面这么写
	  String str1="你看";
        String str2="这";
        String str3="汉堡";
        String str4="做的不好";
StringBuilder builder=new StringBuilder() ;/刚开始什么都没有
builder.append(str1).append(str2) .append(str3) .append(str4) ;//用StringBuilding自带的 	//可以连着写，因为append返回的是builder本身											append()方法（拼接）
        System.out.println(builder.toString());//直接写builder也可以，因为println会自动调用										tostring                                                                       			
结果为：
你看这汉堡做的不好

当然它也可以在new的时候就初始化
比如：
StringBuilder builder=new StringBuilder("hello world");//直接将字符串写在里面
System.out.println(builder);
--------------------------------------------------------
当然还有别的方法
*delete(int x,int y);
//它会删除字符串中第x到第y-1位置的字符（第一个字符也是0开始）
如：
 StringBuilder builder=new StringBuilder() ;
       builder.append("ABC") ;
        builder.append("DEF") ;
        builder.delete(2,5) ;
        System.out.println(builder);

结果为：ABF

*replace();
用法和上面的String的相同，但有一种新的
replace(int x,int y,String str);
将x到y-1的位置的字符串用str代替


*reverse();(反转字符串)

builder.append("ABC") ;
        builder.append("DEF") ;
        builder.reverse() ;
        System.out.println(builder);
结果为：FEDCBA
————————————————————————————————————————
二十一、正则表达式
正则表达式定义了字符串的模式。

正则表达式可以用来搜索、编辑或处理文本。

正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。

一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 "Hello World" 字符串。

.（点号）也是一个正则表达式，它匹配任何一个字符如："a" 或 "1"。



内容非常多，这里只是一部分
javase p55
或者
https://www.runoob.com/regexp/regexp-syntax.html
————————————————————————————————————
二十二、内部类
类的创建有很多方式，并不仅仅局限于普通的创建，内部类顾名思义，就是创建在内部的类，那具体是什么的内部呢？
注意：有点绕
--------------------------------------------------------------------
*成员内部类（非static）**：

我们可以直接在类的内部定义成员内部类（既然是成员，所以是非static的）
如：
public class Test {
    public class Inner {   //内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类
        public void test(){
            System.out.println("我是成员内部类！");
        }
    }
}
**注意：
成员内部类和成员方法，成员变量一样（非static），是对象所有的，如果我们要使用成员内部类，那么就需要：

public static void main(String[] args) {
    Test test = new Test();   //我们首先需要创建外部类对象
    Test.Inner inner = test.new Inner();   //成员内部类的类型名称就是 外部类对象.内部类名称
}--------注意这里的写法，是 外部类+内部类+ 内部类对象名 + = + 外部类对象+ . +new +内部类
//通过外部类的对象，来创建内部类的对象

创建完内部类的对象后就可以使用内部类里面的方法了（要注意不要是private的，支持访问权限控制）

比如：

public class Test {
    class Inner{
         void test(){
            System.out.println("我是内部类方法");
        }

    }
}

public static void main(String[] args) {
    Test test = new Test();   //我们首先需要创建外部类对象
    Test.Inner inner = test.new Inner();   //成员内部类的类型名称就是 外部类对象.内部类名称
	inner.test()；//这里调用了内部类里面的方法
}
结果为：我是内部类方法
------------------------------------------------------------------------------

******由外部类创建的所有对象，都有内部类，而且每个对象的内部类都不同，就是说，每个类可以创建一个对象，而每个对象种都有一个单独的类定义（内部类），可以通过这个成员内部类创建出更多的对象
------------------------------------------------------------------------------
我们说了方法权限不能改为private，那内部类的权限改为private，方法还是public会怎么样呢？
public class Test {
    private class Inner{
        public  void test(){
            System.out.println("我是内部类方法");
        }

    }
}

public static void main(String[] args) {
    Test test = new Test();  
    Test.Inner inner = test.new Inner();//报错，找不到了Inner,想要用，只能改为public  
	inner.test()；
}

------------------------------------
这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的：

public class Test {
    private final String name;
    
    public Test(String name){
        this.name = name;
    }
    public class Inner {
        public void test(){
            System.out.println("我是成员内部类："+name);
                 //成员内部类可以访问到外部的成员变量
              //因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的
        }
    }
}


public class Main {
    public static void main(String[] args) {

        Test test=new Test("小明");
        Test.Inner inner  =test.new Inner();
    inner.test();
    }
}

结果为：我是成员内部类：小明  //所以说，内部类是可以访问到外部类的


****一句话：内部类可以访问到外部类的东西，但是外部类不能访问到成员内部类的东西（注意用词，是成员内部类，如果是后面的静态内部类 ，那么可以访问到静态内部类里的静态属性） （主要看作用域）

为什么外部类，不能访问成员内部类的静态属性呢？因为在java8里面，成员内部类里的不允许出现静态属性的，所以说，连成员内部类里面连静态属性都没有，怎么访问成员内部类的静态属性呢
-------------------------------------------------------------------
当我们在创建几个内部类对象时：

     	  Test test1=new Test("小明");//外部类小明
        Test.Inner inner1 =test1.new Inner();//依赋于外部类小明来创建的内部类对象
        inner1.test();


        Test.Inner inner3 =test1.new Inner();//依赋于外部类小明来创建的内部类对象
        inner3.test();
        

        Test test2=new Test("小红");
        Test.Inner inner2  =test2.new Inner();//依赋于外部类小红来创建的内部类对象
        inner2.test();


结果为：
我是内部类方法小明
我是内部类方法小明
我是内部类方法小红

可以看出，是依附于那个外部类对象的，就是哪个对象的
--------------------------------------------------------------
当内部类与外部类里有同名变量时，我们要怎样去明确使用哪一个呢？

public class Test {
    private final String name;

    public Test(String name){
        this.name = name;
    }
    public class Inner {

        String name;
        public void test(String name){
            System.out.println("方法参数的name = "+name);    //依然是就近原则，最近的是参数，那											就是参数了
            System.out.println("成员内部类的name = "+this.name);   //在内部类中使用this关键字，												只能表示内部类对象
            System.out.println("成员内部类的name = "+Test.this.name);
             			 //如果需要指定为外部的对象，那么需要在前面添加外部类型名称
        }
    }
}

在main中写入：
 Test t=new Test("小明");

        Test.Inner inner=t.new Inner();
        inner.name="小刚";
        inner.test("小红");
        
结果为：
方法参数的name = 小红
成员内部类的name = 小刚
成员内部类的name = 小明

-------------------------------------------------------------------------
包括对方法的调用和super关键字的使用，也是一样的：
public class Inner {

    String name;
    public void test(String name){
        this.toString();		//内部类自己的toString方法
        super.toString();    //内部类父类的toString方法
        Test.this.toString();   //外部类的toSrting方法
        Test.super.toString();  //外部类父类的toString方法
    }
}

**所以说成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用。
—————————————————————————————————————————————
****静态内部类：有static****
---------------------------------------------------------------------------------------
前面我们介绍了成员内部类，它就像成员变量和成员方法一样，是属于对象的，同样的，静态内部类就像静态方法和静态变量一样，是属于类的，我们可以直接创建使用。
----------------------------------------------------------------------------------------
与静态成员变量和方法一样。它是属于类(属于外部类)的，也就是说它可以由外部类直接访问，而不用创建外部类的对象，再使用内部类
如：
public static class Inner{//Inner为静态内部类
}

你可以直接创建对象了，而不需要像成员内部类一样，先创建外部类对象，在通过外部类对象创建内部类对象
 
Test.Inner inner=new Test.Inner();//不需要依附外部类对象，直接创建内部类对象
-----------------------------------------------------------------------------------------
静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的
****外部类只能访问静态内部类的静态属性（注意用词，是静态内部类，不是成员内部类)，其他的成员属性不行

*以上一句话概括：静态类内部不能访问外部类的非静态属性，只能访问静态属性（就是之前说的静态内容只能访问静态内容）
只不过受影响的只是外部内容的使用，内部倒是不受影响，还是跟普通的类一样：
内部（就是它自己本身）可以随便用自己的东西
-----------------------------------------------------------------
如果内部类里也有static方法(而且外部类也可以直接访问静态属性)
public static class Inner{
     public static void test1(){}
    }

你也可以直接通过类来访问
如: Test.Inner.test1();
---------------------------------------------------------------------------
静态内部类加载也是一样的：
.class文件是给jvm去执行的，而每一个.class文件就是类，
java中使用一个类之前，jvm不会在一开始就去加载它，而是在用到的时候就会去加载类：

1.访问静态变量，或者为静态变量赋值,调用静态方法
2.new 创建类的对象（隐式加载）
3.子类初始化
4.其他

来各例子：
public class Test {

  static{
      System.out.println("我是外部类初始化");
  }

  public static class Inner{

      static{
          System.out.println("静态内部类初始化");
      }

      public static void test(){
          System.out.println("我是静态内部类方法");
      }
      
  }

}
当我们在main中只调用test()方法：

Test.Inner.test();

结果会是什么？
结果为：
静态内部类初始化
我是静态内部类方法

//可以看到并没有初始化外部类 只有静态内部类初始化了
为什么会这样呢？

当我们打开反编译文件，发现jvm弄了两个class文件
一个是Test.class
另一个是Test$Inner.class
所以说两个类（外部类和静态内部类）是分别编译的

因为上面我们只调用了静态内部类的方法，所以只有静态内部类加载了，而外部类不会加载，只有当我们使用外部类里面的内容时，才会加载外部类
-----------------------------------------------------------------------------------------
***局部内部类（定义在方法里面的类，它的作用域只能在方法的花括号里）****************
局部内部类，就像局部变量一样，可以在方法里定义
定义在方法中的类
如 
public void test(){

       class Inner{//Inner的作用域仅限在test()方法里，所以不能加权限修饰符，static
       }

   }

这样Inner的作用域只能在这个test方法中 不能加权限修饰符（因为方法中的东西只能在方法中有用，不能加权限修饰符，也不能用static）

这种局部内部类的形式（仅限于在方法里的局部内部类），使用频率很低，基本上不会用到，所以了解就行
------------------------------------------------------------------------------------

******************************************
***注意以下这个非常重要一定要学懂，ok？*******
*******************************************
-------------------------------------------------------------------------------------
***匿名内部类***（重要）（使用频率非常高）

1.在之前抽象类和接口的学习过程中，我们知道不能直接通过new的方式去创造一个抽象类对象或者接口对象，要先继承子类，再重写抽象方法，然后才能创建抽象类子类的对象。
（一句话概括：不能直接创建抽象类或者接口的对象，而是应该先创建抽象类或接口的子类，让它们的子类实现抽象方法，然后我们还不能创建抽象类或接口的对象，而是只能创建它们子类的对象，但是抽象类或接口里的方法都有，因为是继承来的）（用实现了抽象类和接口的子类名来创建）
而使用匿名内部类可以快速创建一个抽象类或接口的对象（直接用抽象类或者接口的名字来new）
----------------------------------------------------------------------------------------
2.使用匿名内部类

比如有一个抽象类（可以有抽象方法的类）Student 

public abstract class  Student {
    String name;
    public abstract void test();
}

如果我们使用匿名内部类来创建的话（不用再创建类去实现抽象类或接口）
main中直接创建
就可以这样写

 Student student = new Student() {//通过匿名内部类，就可以直接通过new来创建一个抽象类的对象了
            @Override	          //注意怎么写的，加个{}然后在里面重写抽象方法就可以了
            public void test() {  //大括号也可以看成抽象类的子类
                System.out.println("我是匿名内部类");
            }
		
	student.test();
        };
（这样就直接创建了一个抽象类Student的对象
这里创建出来的 Student，就是一个已经实现了抽象方法的类了，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接创建出对象）
结果为：
我是匿名内部类
-----------------------------------------------------------------------------------------
3.匿名内部类本身也是一个类

你可以在里面额外定义变量，方法（一定要重写了抽象方法），当然也可以访问到父类（抽象类Student）的可访问 变量和方法
如
Student student = new Student() {
		String a;//额外添加成员属性

            @Override	   
            public void test() {
                System.out.println(name+"我是匿名内部类");//还可以直接使用父类的属性
            }

        };
匿名内部类中同样可以使用类中的属性（因为它本质上相当于是对应类型的子类）
------------------------------------------------------------------------------------------
4.接口也可以通过匿名内部类来直接创建一个匿名的接口实现类
如：
有一接口

public interface Study {
    void study();
}
你可以用匿名内部类：
 Study study=new Study() {//这里其实还可以更简单，使用lambda表达式
            @Override
            public void study() {
                System.out.println("我是匿名内部类");
            }
        };
------------------------------------------------------------------------------------------
5.普通的类也可以用匿名内部类（不过意义不大），也可以直接new

普通类
public class Test {
}

你可以使用匿名内部类
  Test test=new Test() {
           //里面可以写你想要的内容
       };

—————————————————————————————————————————————
二十三、lambda表达式（只支持只有一个待实现的抽象方法的接口）
前面我们介绍了匿名内部类，我们可以通过这种方式创建一个临时的实现子类
--------------------------------------------------------------------------------------
1.特别的，如果一个接口中有且只有一个待实现的抽象方法，那么我们可以将匿名内部类简化为lambda表达式
注意是只有一个待实现的抽象方法

如 Study study= new Study(){
           @Override
           public void study() {
               System.out.println("hello");
		   System.out.println("world");
           }
       };
可以简化为

Study study= () -> {System.out.println("hello");System.out.println("world");};

如果只有1个语句那么，{}可以不写（和c语言for语句那些类似）

我们刚开始学可以将lambda表达式看成匿名内部类的简写（但实际没有那么简单）
---------------------------------------------------------------------------------------
2.简写规则
*标准格式：    
 （参数类型 名称，...）->{代码语句，包括返回值}； //参数是接口中待实现抽象方法的参数
					   //如果只有1个语句那么，{}可以不写（和c语言for语句那些类似）
 如：Study study= () ->System.out.println("hello world");


*和匿名内部类不同，lambda表达式仅支持接口，不支持抽象类
*接口内部必须有且仅有一个待实现的抽象方法（可以有多个抽象方法，但是必须保证其他抽象方法有默认实现（default），必须留一个抽象方法待实现）

如，这样可以
public interface Study {
    void study(int a);

    default void xxx() {//默认方法实现
        
    }
}
如果待实现方法有参数，那么lambda表达式里要有参数，但参数类型可以不写，如果只有一个参数，那么（）小括号也可以省略，只留一个参数

-----------------------------------------------------------------------------------------
我们来看一下Lambda表达式的具体规范：

标准格式为：([参数类型 参数名称,]...) ‐> { 代码语句，包括返回值 }
和匿名内部类不同，Lambda仅支持接口，不支持抽象类
接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）
-----------------------------------------------------------------------------------------
例子：
接口里的抽象方法： String study(int a);

匿名内部类（有参数，且重写只有返回结果）
  Study study= new Study(){
           @Override
           public String study(int a) {
		System.out.println("我是学习方法”)；
               return "今天学会了吗"+a;
           }
       };
那么可以写为

Study study= （int a）->{
System.out.println("我是学习方法”)；
return "今天学会了吗"+a
};

但还可以进一步简洁为
Study study= (a)->{//省略参数类型
System.out.println("我是学习方法”)；
return "今天学会了吗"+a
};

如果只有一个参数，可以把（）省略

Study study= a->{//省略参数类型
System.out.println("我是学习方法”)；
return "今天学会了吗"+a
};

当如果重写语句只有一句时，你还可以把{}省略，是不是极致的省

而且如果重写语句只有一句，而且这一句为返回语句，那么我们连return都可以没有，直接写返回内容
像这样：

Study study= a->今天学会了吗"+a； ==	Study study= a->{
						return "今天学会了吗"+a
						}
----------------------------------------------------------------------------------
3.
如果一个方法的参数需要的是一个接口的实现（一般就是要创建一个子类，然后重写抽象方法）
（就是传一个接口的子类作为参数，这个子类可以写成lambda表达式）


public static void main(String[] args) {
    test(a -> "今天学会了"+a);   //参数直接写成lambda表达式
}

private static void test(Study study){
    study.study(10);//study对象调用Study里的study方法
}
----------------------------------------------------------------------------------------
4.当我们在匿名内部类中想要使用外面的局部变量
  int a=10;

Study study=new Study(){
    @Override
    public void study() {
        System.out.println(a);
    }
};
或者Study study= () -> System.out.println(a);

这样是可以的

但是有个前提，a必须为final或隐式final，也就是说a的值不能改变（过），
而且在内部类中使用过后a的值也不能变（不能进行a++之类的操作）
————————————————————————————————————————————————————————————————
二十四、方法引用
------------------------------------------------------------------------------------
1.方法引用，就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义得一样才行，方法名字可以不一样）
比如

接口中：
public interface Study {
  int sum(int a,int b);

}
一般用lambda表达式的写法：
在main中创建Study的匿名内部类你可以：
 Study study=(a,b)->a+b;

第二种
因为Integer类中默认提供了求两个int值之和的方法

即Integer类中有：public static int sum(int a,int b){
            return a+b;
     }

我们可以直接将上面Integer中的sum方法作为接口的实现

Study study=(a,b)->Integer.sum(a,b);//直接调用Integer为我们通过好的sum方法

第三种：
*方法引用：（十分简洁）
Study study= Integer::sum;//直接将Integer中的sum方法作为Study的方法实现
//这里的sum是Integer中的静态方法，属于Integer类，可以通过类来用sum，但是如果不是静态方法，那么就要通过对象来使用了，如  对象：：方法

像这样
接口：
public interface Study {
  String study();

}
main方法里：
public class Main {
    public static void main(String[] args) {
        Main main=new Main();//要创建
     Study study= main::test;//1.引用的方法名字可以与抽象方法不一样（只要内容一样就可以）
                            //2.不是静态方法，那么就要通过对象来使用了
	 System.out.println(study.study());
    }
    public String test(){//非静态方法
        return "hello";
   }
}
结果为：hello
-------------------------------------------------------------------------------------
2.方法引用其本质上就是相当于将其他的方法的实现，直接作为接口中抽象方法的实现，任何方法都可以通过方法引用作为实现
--------------------------------------------------------------------------------------
技巧：由于String 类在创建对象的时候也会返回一个String 的结果

由于接口中返回类型为String
public interface Study {
  String study();

}
我们就可以直接将string 的构造方法作为方法引用
Study study=String::new;//用new来实现
   不过得到的值会是个空串（如果是无参构造）

 Study study=String::new;
        System.out.println(study.study() );
    }
结果为：    （空）
______________________________________________________________________________________
二十五、异常机制
异常和错误：都是一种类（类定义：就是定义成一个类的）
------------------------------------------------------------------------------------
1.异常

异常类型： 分为运行时异常和编译时异常

运行时异常继承RuntimeExpection，而RuntimeExpection又继承Expection
编译时异常直接继承Expection

运行时异常：都继承RuntimeExpection

就是编译的时候没有问题，但是当我们写入几个参数时，不符合实际，我们这时就为运行时异常

如：AritmeticException（算数异常），空指针异常，类型转换换异常等



编译时异常：  都继承Exception类

编译时，明确指出可能会出现的异常，在编译阶段需要进行处理（捕获异常），必须要考虑到出现异常的情况，如果不进行处理，就无法通过编译
（明确会发生，必须要处理）

例如：
@Override
    protected Object clone() throws CloneNotSupportedException {

        return super.clone() ;
    }

   Main main=new Main();
   main.clone() ;
会显示
处理 异常: java.lang.CloneNotSupportedException
这就是编译时异常
------------------------------------------------------------------------------------
2.错误（error）：比异常更严重，会影响到jvm

 当然还有一种类型是Error，它是所有错误的父类，同样是继承自Throwable的。

如
StackOverflowError 栈溢出错误
OutOfMemoryError  超出内存错误

**异常可能不会导致致命问题，但错误一定会导致致命问题

***不管是异常还是错误，最终都继承Throwable

-----------------------------------------------------------------------------------------
二十六、抛出异常
先打个疫苗针，抛出异常不是处理异常，发生异常后，如果代码中没有处理，那么程序是会异常终止的

异常的处理有两种：1.添加到方法签名  2.使用try-catch语句来对 可能发生异常的语句进行监控，必要时会抓取异常， 只要异常处理了后，那么程序就不会异常终止
-----------------------------------------------------------------------------------------
1.我们不仅仅是系统抛出异常，我们还可以手动抛出异常，同时告知上一步出现了问题

注意：我们这里的抛出的都是运行时异常，是可以不处理的（但如果是抛出的是编译时异常，是要处理的）
	当然运行时异常也是额可以处理的，只不过没必要
*我们可以使用关键字throw 来抛出异常：

public static int ff(int a,int b){
        if(b==0){
            ArithmeticException expection=new ArithmeticException("除数不能为0");//先创建一个												对应异常类型的对象
            throw expection ;
        }
        return a/b;
   }

异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在RuntimeException的构造方法中我们可以写入原因。
 
一句话：概括，要抛出异常，先创建对应运行时异常的对象，然后抛出这个对象

比如这里：
ArithmeticException expection=new ArithmeticException("除数不能为0");//原因写在括号里
ArithmeticException这个类里面的构造方法其实也是重载了很多种的，你可以创建很多种异常对象
------------------------------------------------------------------------------------------
但是为了简单：我们一般直接在throw的时候new
比如：
  public static int ff(int a,int b){
        if(b==0){
            
            throw new ArithmeticException("除数不能为0");//直接在throw后面new一个异常
        }								  //这样会更方便
        return a/b;
   }

结果为：
Exception in thread "main" java.lang.ArithmeticException: 除数不能为0
	at Main.ff(Main.java:12)//指明异常发生的地方
	at Main.main(Main.java:7)

这样出现了红字（注意这里没有处理异常，如果处理了就不会出现红字）

如果我们抛出的是运行时异常对象或者是它的子类的对象(RuntimeExpection,ArithmeticException等)，那么直接抛出就行，不用处理异常（添加方法签名，try-catch）
------------------------------------------------------------------------------------------
******************************************************************************************
*但是如果我们抛出的异常不是运行时异常，*而是编译时异常（Expection）*，那么必须告知函数调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理（添加方法签名，try-catch）后才可以抛，不然会报错
如：
public static int ff(int a,int b) {
        if(b==0){
            throw new Exception("除数不能为0");//抛出的是编译时异常，一定要处理
        }
        return a/b;
   }
如果这么写，它会报错，未处理 异常: java.lang.Exception


处理有两种

-------------------------------------------------------------------------------------------
1.添加异常到方法签名
像这样
public static int ff(int a,int b) throws Exception {  <---添加到这里
        if(b==0){
            throw new Exception("除数不能为0");
        }
        return a/b;
   }

这样写有两个作用：
1.明确告诉调用方，这里可能会抛出一个错误，要处理
2.如果添加到这里，那么可以继续往上一级抛


处理：在调用这个函数时我们可以在方法签名中添加异常 （就是上面说的继续向上一级抛）
    public static void main(String[] args) throws Exception{ <--这里 使用throws关键字
    ff(3,0);
        System.out.println("hello");
    }

}
------------------------------------------------------------------------------------------
2.用try/catch

    public static void main(String[] args)  {
        try {
            ff(3,0);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

}
----------------------------------------------------------------------------------------
*如果一个方法中，因为分支不同可能会出现多个不同的异常，那么所以在方法中可能出现的异常需要注明（编译时异常一定要写，运行时异常可以不写）

如：这里是编译时异常 
public static void  ff(int b) throws FileLockInterruptionException, ClassNotFoundException {

        if(b==0){

            throw new FileLockInterruptionException() ;//编译时异常
        }
        else  throw new ClassNotFoundException() ;

   }
throws有了个s，异常用逗号隔开

如果是运行时异常，那么可以不写，也可以写
--------------------------------------------------------------------------------------
最后在提一句：
如果一个方法中明确了要抛出异常，但它的重写方法中可以不抛出异常，但是重写方法中会出现异常那么还是要注明异常
如：重写clone方法
  @Override
    protected Object clone(){//不会出现异常,就把throws CloneNotSupportedException给删了,不用写
         return "hello" ;//不会出现异常
    }

而在Object类中的clone方法
 protected native Object clone() throws CloneNotSupportedException;
—————————————————————————————————————————————
二十七、异常的处理
1.当程序没有按照我们理想的样子运行而出现异常时（默认会交给jvm来处理，jvm发现任何异常都会立刻终止程序运行，并在控制台打印栈追踪信息），现在，我们希望能够自己处理出现的异常，让程序继续运行下去，就需要对异常进行捕获
（jvm处理就是抛出异常并终止程序运行，在控制台打印栈追踪信息）
（我们处理就是会抛出异常，但不会终止程序）
-------------------------------------------------------------------------------------------
2.异常的捕获：
使用 try-catch语句来实现捕获异常

     try {
            Object object = null;
            object.toString();//这两句为被监控的语句
        }catch(NullPointerException e){//如果被监控的语句发生了catch括号里的异常，那么e就会去接							收那个异常
          e.printStackTrace();//打印栈追踪信息
        }
        System.out.println("程序正常进行");
    }
解释：如果try里面的语句出现了相应的异常，那么catch就会捕获异常让e去接收，e是一个异常的对象，然后再catch(){}大括号里，可以对e进行操作（比如e.printStackTrace() ;打印栈追踪信息）

结果为：
java.lang.NullPointerException//是打印捕获的异常
	at Main.main(Main.java:12)
程序正常进行

注意各个部分的代表内容
try内部的语句是被监控的语句
catch（）里是捕获类型 +对象名
***（*注意捕获类型只能是Throwable或其子类，也就是说要么是抛出的异常，要么是错误，不能是其他任何类型，因为Throwable是最顶层的，异常和错误都继承它）

---------------------------------------------------------------------------------------
另外，如果try里的异常与catch里的异常相同的话，程序不会异常终止会继续执行下面的语句
但是，如果try里的异常与catch里的异常不相同的话，程序还是会交给jvm来处理，程序会异常终止

如：

 try {
            Object object = null;
            object.toString();//发生的是空指针异常
        }catch(ArithmeticException  e){//可以接收算数异常
   	 e.printStackTrace() ;
        }
        System.out.println("程序正常进行");
    }

结果：
Exception in thread "main" java.lang.NullPointerException
	at Main.main(Main.java:12)

可以看出：发生的异常与能接收的异常不同，当发生异常后，并不能捕获，只能交给jvm来处理，这样当
抛出异常后，程序就异常终止了
--------------------------------------------------------------------------------------
捕获错误：（这种不推荐，因为出现错误了，可能后果不会比较严重）
  try {
         int [] arry=new int[Integer.MAX_VALUE ];
        }catch( Throwable e){//错误也是继承Throwable类
    e.printStackTrace() ;
        }
        System.out.println("程序正常进行");
    }

结果为：
java.lang.OutOfMemoryError: Requested array size exceeds VM limit
	at Main.main(Main.java:11)
程序正常进行
-------------------------------------------------------------------------------------
如果某个方法明确指出会抛出哪些异常（编译时异常（Expection）一定会指出，而运行时异常RuntimeExpection)不一定指出），
除非抛出的异常是一个运行时异常，否则我们必须使用try-catch语句块进行异常捕获（要么在抛出异常的方法里用try-catch处理，要么指明在签名，抛给上一级处理），不然就无法通过编译

举例说明：

这是一个编译时异常：

public static int test(int a,int b) throws Exception{
        if(b==0){
            throw new Exception("除数不能为0") ;//方法明确指出会抛出这个编译时异常
        }						      //所以一定要对其进行处理，不然会报错
        return a/b;
}


解决方法有两种：

第一种：是在这一级（这个方法)里面处理，直接用try-catch语句直接捕获异常

public static int test(int a,int b)  {
        if(b==0){
            try {
                throw new Exception("除数不能为0");//用try-catch语句直接捕获异常
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return a/b;
}

第二种：
当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级

丢给上一级处理：

public static int test(int a,int b) throws Exception {//将编译时异常添加到方法签名,会抛给上一级
        if(b==0) throw new Exception("除数不能为0") ;//方法明确指出会抛出一个编译时异常
        return a/b;
}

注意：如果这一级方法已经是main方法了，那么丢给上一级后，就是给jvm处理了（就相当于没处理）

上一级的处理：
//用try-catch语句块去捕获异常，当然还可以给它的上一级处理（但因为这一级是main方法了，那么它的上一级就是jvm了，所以只能使用try-catch语句来处理）
  public static void main(String[] args){//在main中对可能异常的方法使用try-catch语句
     try {
            test(10,0);//监控
        } catch (Exception e) {//捕获
            e.printStackTrace() ;//打印栈追踪信息
        }
        System.out.println("程序正常进行");
    }
public static int test(int a,int b) throws Exception {//将编译时异常添加到方法签名,会抛给上一级
        if(b==0) throw new Exception("除数不能为0") ;//方法明确指出会抛出一个编译时异常
        return a/b;
   }
}
----------------------------------------------------------------------------------------
理解上一级：

public class Main{
    public static void main(String[] args) throws Exception {//抛给上一级处理（jvm）
        a();//main（）调用了a方法，所以main方法是a方法的上一级
    }
    
    static void a() throws Exception {//抛给上一级处理
        b();//a方法调用了b方法，所以a方法是b方法是上一级
    }
    static void b() throws Exception {//抛给上一级处理
        c();//b方法调用了c方法，所以b方法是c方法的上一级
    }
    static void c() throws Exception {//抛给上一级处理
        throw new Exception("我是异常");//最下面是c方法会抛出一个编译时异常 
    }
}
只要一级处理了，那么上面就不用再处理了
------------------------------------------------------------------------------------------
3.当代码可能出现多种类型的异常时，我们希望能够分不同的情况处理不同类型的异常，就可以使用多重异常捕获

try{
  	...
}catch(异常类型 e){
  	... 
}catch(异常类型 e){
	...
}catch(异常类型 e){
	...
}
像这样：
  try {
           int[] arr=new int[10];
           arr[-1]=10;//会发生数组越界异常
        } catch(NullPointerException e) {//捕获空指针异常
            e.printStackTrace();
        } catch (ArrayIndexOutOfBoundsException e){//捕获数组越界异常
            e.printStackTrace() ;
        }
        
        System.out.println("程序正常进行");

但要注意顺序
像这样：下面的是上面的父类(RuntimeException是ArrayIndexOutOfBoundsException的父类）
try {
           int[] arr=new int[10];
           arr[-1]=10;
        } catch(NullPointerException e) {
            e.printStackTrace();
        } catch (ArrayIndexOutOfBoundsException  e) {
            System.out.println("我是数组越界异常");
        }catch(RuntimeException e){		//父类异常不允许出现在子类异常前面
            System.out.println("我是运行时异常");
        }

结果为：
我是数组越界异常
程序正常进行

注意：它并不会让RuntimeException和ArrayIndexOutOfBoundsException都捕获，而是让最先捕获它的捕获（就是只能被捕获一次）

---------------------------------------------------------------------------------------
还有：如果父类异常在子类异常前了，这是不允许的
 try {
           int[] arr=new int[10];
           arr[-1]=10;
        } catch(NullPointerException e) {
            e.printStackTrace();
        }
        catch(RuntimeException e){
            System.out.println("我是运行时异常");
        }catch (ArrayIndexOutOfBoundsException  e) {
            System.out.println("我是数组越界异常");
        }

错误原因：已捕捉到异常 'java.lang.ArrayIndexOutOfBoundsException'
----------------------------------------------------------------------------------------
当然多重catch捕获不同的异常可以合并，用|隔开
如：
 try {
         int[] arr=new int[10];
         arr[-1]=10;
        } catch(NullPointerException | ArrayIndexOutOfBoundsException  e) {//用|隔开
			//不管是上面异常都执行这里的语句
      }
当然，也可以像上面分开写
-----------------------------------------------------------------------------------------
4.*****finally关键字****
和try，或try-catch一起用
**如果我们想让程序无论有没有发生异常，都会执行一个语句，那么我们可以用finally
像这样：
 try{
           int[] arr=new int[10];//这里发生了异常（因为没有捕获，所以正常来说应该会异常终止，但因                        						为有finally,所以仍然会执行finally里的语句，再报异常）
           arr[-1]=10;
        }finally {
            System.out.println("我是finally");
        }

结果为：
 我是finally   
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: -1
	at Main.main(Main.java:13)

注意：finally至少要和一个try 或 catch一起用

思考：try catch finally 执行顺序
———————————————————————————————————————————————————————————————————
二十八、断言表达式（只了解就可以）
assert +表达式  ：“ 错误信息”；     表达式为true就正常  false就抛出断言错误
javase p64
———————————————————————————————————————————————————————————————————
二十九、数学工具类
前面我们学习了包装类，数组和字符串，我们接着来看看常用的一些工具类，工具栏就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用
-------------------------------------------------------------------------------------------
 Math类里面有很多数学方法，可以使用（如pow()幂次方   fabs()绝对值   sqrt()算术平方根   三角函数以及对应反函数,对数函数）

注意：在Math类里,有很多静态常量 如：PI(3.14) E(2.71828） 

对数函数单独看： log表示数学里的ln（注意是ln，以e为底的对数函数） log10（以10为底的对数函数）
		如果是普通数，我们可以使用换底公式

还有一些特殊方法：Main.ceil()向上取整，如Main.ceil(3.4) 为4， Main.ceil(-3.4)为-3
		    Main.floor()向下取整  如Main.floor(1.5) 为1   Main.floor(-1.6) 为-2
-------------------------------------------------------------------------------------------
生成随机数:Random()

先导入import java.util.Random;
再创建一个对象
Random random=new Random();
再使用
random.nextInt(100);
这样就生成了一个100以内的随机数

random.nextDouble()；生成一个0到1之间的小数（不用加参数）

注意：这里生成的数看似是随机的，实际上是按照某些东西计算出来的，只不过计算过程十分复杂，能够在一定程度上保证随机性
———————————————————————————————————————————————————————————————————
三十、数组工具类:Arrays类
先导入：import java.util.Arrays;
-----------------------------------------------------------------------------------------
1.用toString 方法打印一维数组：（依然可以用for或foreach）

 Arrays.toString(arr)；会返回一个字符串

如： int[] arr=new int[]{1,2,5,8,90,4,6,4,3};

        System.out.println(Arrays.toString(arr));

结果为：
[1, 2, 5, 8, 90, 4, 6, 4, 3]
------------------------------------------------------------------------------------------
2.用Arrays.deepToString（）；方法打印多维数组

如果是多维数组，我们用Arrays.toString（）；方法打印只能打印出引用（数组的引用，即地址）
如：
int[][] arr=new int[][]{{1,2,3,4},{5,6, 8,8,9}};

        System.out.println(Arrays.toString(arr) );
结果为：
[[I@6bc7c054, [I@232204a1]//因为Arrays.toString();只能解析一层，

*如果我们要打印内容，我们要用Arrays.deepToString();

int[][] arr=new int[][]{{1,2,3,4},{5,6, 8,8,9}};

        System.out.println(Arrays.deepToString(arr)  );

结果为：[[1, 2, 3, 4], [5, 6, 8, 8, 9]]
-----------------------------------------------------------------------------------------
3.排序数组方法：Arrays.sort()

这个方法没有返回值，直接在数组上修改，**这个方法里面有很多种排序算法，如双轴排序，快速排序等

比如：
int[] arr=new int[]{1,2,5,8,90,4,6,4,3};
        Arrays.sort(arr);//不止是int型，甚至还有引用类型，有个重载方法是泛型的
        System.out.println(Arrays.toString(arr));

排完序后
结果为：[1, 2, 3, 4, 4, 5, 6, 8, 90]
-----------------------------------------------------------------------------------------
4.填充数组：Arrays.fill()
如：
int[] arr=new int[10];
        Arrays.fill(arr,5);//用5来填充数组
        System.out.println(Arrays.toString(arr));

结果为：
[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
------------------------------------------------------------------------------------------
5.复制数组方法：

*Arrays.copyOf(要复制的数组,复制的长度);这个是从头开始的，复制的长度可以大于数组的长度，超过的会为0
如：
 int[] arr=new int[]{1,2,3,4,5};

       int[] target=Arrays.copyOf(arr,5);//要用target

       System.out.println(Arrays.toString(target));

结果为：[1, 2, 3, 4, 5]


*Arrays.copyOfRange(被复制的数组，起始位置，末位置)；//复制从起始位置到末位置-1的元素
如
int[] arr=new int[]{1,2,3,4,5};
       int[]target=Arrays.copyOfRange(arr,1,5) ;
        System.out.println(Arrays.toString(target));
结果为：
[2, 3, 4, 5]


*System.arraycopy(被复制的数组，被复制数组的起点，容器数组，容器数组的起点，被复制数组起点开始几个元素)//将一个数组里的元素复制到另一个数组里


 int[] arr=new int[]{1,2,3,4,5};
       int[]target=new int[10];
       System.arraycopy(arr,2,target,5,3) ;
        System.out.println(Arrays.toString(target));


结果为：[0, 0, 0, 0, 0, 3, 4, 5, 0, 0]


-------------------------------------------------------------------------------------------
*二分搜索Arrays.binarySearch(被搜索的数组，目标元素)//注意传入的数组一定是升序的，目标如果不存在，就返回-1
-------------------------------------------------------------------------------------------
6.判断两个数组的内容是否一样：


我们都知道用== 和equals()（equals没有重写）;
来判断两个数组（一维或多维）是否一样的话，就算内容一样也会显示false，
因为这两个是看是不是同一个对象（内存地址）


	int[] a=new int[]{1,2,3,4};
      int[] b=new int[]{1,2,3,4};

	System.out.println(a==b );
      System.out.println(a.equals(b));//用未重写的equals方法与==是一样的

结果为：
false
false

*这时候我们可以用Arrays.equals()//数组工具类里面重写过的equals()
来判断两个一维数组的内容是否相同（注意是一维数组）

int[] a=new int[]{1,2,3,4};
    int[] b=new int[]{1,2,3,4};
System.out.println(Arrays.equals(a,b)  );

结果为：
true

*如果是多维数组：用Arrays.deepEquals()

用Arrays.deepEquals()；方法来判断多维数组的内容是否相同
如：
int[][] a=new int[][]{{1,2,3,4},{5,6,7,8}};
    int[][] b=new int[][]{{1,2,3,4},{5,6,7,8}};
 System.out.println(Arrays.deepEquals(a,b) );
结果为：
true
-----------------------------------------------------------------------------------------
8.Arrays.asList();可以快速生成一个只读的List：
注意这个list是只读的，不可以修改，只能使用获取内容的方法，要正常使用，可以结合List类来使用



————————————————————————————————————————————————————————————————————————————————
三十一、泛型类
-------------------------------------------------------------------------------------------------------------------
我们为什么要泛型？
因为
在一个类中，
如：如果我们想要让一个变量为多种类型（在创建对象的时候来确定类型），我们可以用Object类，因为其他的类都继承Object,并且基本类型用对应的包装类来表示（可以自动装箱），这样，变量的类型就取决于我们创建对象时输入的值

public class Score {
    private String name;
    private String id;
    private Object value;

    public Score(String name,String id,Obejct value){
        this.name =name;
        this.id =id;
        this.value=value;
        
    }

    public Object getValue() {
         return value;
    }
}

这样，就能实现，一个变量出现两种类型了，但是这样有局限性，因为，我们不知道一个对象的这个变量的类型是什么，如果盲目用强制类型转化，可能会出错
如：

Score s1=new Score("线性代数","ijbnion","优秀");
Integer i=(Integer) s1.getValue() ;

这里s1里面的Value为String类型，而它不能被转化为Integer类型，所以会出错

Exception in thread "main" java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Integer (java.lang.String and java.lang.Integer are in module java.base of loader 'bootstrap')
	at Main.main(Main.java:16)

-------------------------------------------------------------------------------------------------------------------
使用Object 尽管是一种可行的方法，但是并不是一种最优的方法

最优解为：
所以我们可以使用泛型类
-------------------------------------------------------------------------------------------------------------------
1.泛型类：
**泛型类是一种类，泛型是一种类型（待定）
类型参数表示泛型

**泛型类中泛型参数表示的只能为引用类型，而不能是基本类型，（可以是基本类型包装类，和数组类，因为这也是引用类型）(数组类型是基本类型还是引用类型都可以)
Integer Void ...String ...int[] 

如：数组类型int[] arr=new int[]{1,23,3};
        Score<int[]> s = new Score<>("高等数学", "asfsdfs", arr);

-------------------------------------------------------------------------------------------------------------------
泛型就是一个待定的类型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应类型
我们可以使用一个特殊的名字来表示泛型（只要是合法标识符，建议只写一个字母）
我们可以将一个类定义为泛型类，用<>来实现

比如：
public class Score<T> {//<>里为泛型类的类型参数,（表示待定类型）可以添加1-N个类型参数
    private String name;
    private String id;
    private T value;//T会根据使用时提供的类型自动变成对应类型

    public Score(String name,String id,T value){//T可以是任何类型，但是一旦确定陆地，那么就不能                    													修改了
        this.name =name;
        this.id =id;
        this.value=value;

    }

    public T getValue() {
         return value;
    }
}

***另外：类型参数是未知的，只有当创建对象时才知道，所以属于对象，所以静态内容里就不能使用类型参数（重要）
-----------------------------------------------------------------------------------------------------------
2.泛型的使用

我们可以在类后面用<>（钻石运算符）来明确泛型具体是什么类型（注意一定是引用类型，而不是基本类型）
这样我们可以得到提示
    Score<String> math=new Score<String>("高等数学","2022061","优秀")；
这样我们明确泛型具体是什么类型后，我们填入的实参类型就一定要是确定好的类型，不然会报错
//这样是最标准的写法，泛型类名<具体类型> 对象名=new 构造方法<具体类型> //构造方法里的具体类型可以省
										
    System.out.println(math.getValue() );
---------------------------------------------------------------------------------------------------------------
当然我们也可以在泛型类中定义多个类型参数
public class Score<T,U> {//用逗号隔开
    private String name;
    private U id;
    private T value;

    public Score(String name,U id,T value){
        this.name =name;
        this.id =id;
        this.value=value;

    }

    public T getValue() {
         return value;
    }
}

使用时：要按顺序用逗号隔开
  Score<String,Integer> math=new Score<String,Integer>("高等数学",20220111,"优秀") ;
        System.out.println(math.getValue() );

对于这里：
public T getValue() {
         return value;
    }

当我们在泛型类中的方法里使用待确定类型的变量时，因为此时不明确是什么类型，所以会默认这个变量为Object
因为无论具体类型是什么，一定是Object类的子类 

我们可以对其进行强制类型转化，但是没多大必要了，因为我们都明确用什么类型了
**另外我们不能通过不确定的类型参数（泛型）去创建对象和数组（类型参数不能实例化）

比如：
 T[] array=new T[10];//这样写是错误的


**我们只能在泛型类和泛型方法中使用我们的类型参数（泛型）

**具体类型不同的泛型类变量（对象），不能使用不同的变量进行接收
这样不行
 Score<String> math=new Score<String>("高等数学","sakfifj","优秀") ;
        Score<Double> math1=math;//一个String 一个Double


-------------------------------------------------------------------------------------------------------------------
3.通配符  ? 表示任意类型
如果我们想创建一个可以接收任何具体类型的对象，我们可以使用通配符 ? 

Score<?> s = new Score<>("高等数学", "asfsdfs", "优秀");//？表示可以接收任意类型的
这样我们的Value变量就可以接收任何类型的值了，注意构造方法里的<>可以什么都不写（但一定不能写?），但是如果你写了一种具体类型，那么你后面传入的参数必须是这个具体类型，不然报错，

如果这样写：
Score<?> s = new Score<>("高等数学", "asfsdfs", "优秀");//构造方法里不写具体类型（引用）
那么我们就不知道 它的具体类型，系统会将他当作Object类，要明确的话,可以

**注意：泛型类中泛型参数表示的只能为引用类型，而不能是基本类型，要用基本数据类型的话，只能用对应的包装类
	但是数组可以，不管是什么类型的数组（基本类型还是引用类型数组），因为数组本身就是一种引用类型
-----------------------------------------------------------------------------------------------------------------
泛型与多态：
不止是类，包括接口，抽象类都是可以支持泛型的

1.泛型不仅仅在普通类中使用，在接口，抽象类中都是支持泛型的

如：
public  interface test<E> {
    E test();
}
这是一个接口，有个类型参数E，还定义了一个 E类型的抽象方法


我们可以在A类中实现接口：
public static class A implements test<String> {//这样直接将E具体类型明确为String
        @Override
        public  String test (){//这样test的类型就是String 了
            return null;
        }
    }


你甚至可以在实现接口的时候也用类型参数
public static class A<T> implements test<T> {
        @Override
        public T test (){
            return null;
        }
    }


直到
在创建类型对象的时候才确定具体类型
A<Integer> a=new A<>();


继承：同样的使用
public static class A<H>  {
      
    }

public static class B extends A<String>{
        
    } 

当我们在创建对象是才能明确具体的类型，而每个对象的类型又可以不一样，所以这也是多态的体现

————————————————————————————————————————————————————————————————————————————————
三十二、泛型方法：并不是只能在泛型类里面创建泛型方法，你可以在任何地方创建泛型方法

当然类型参数，不只是在泛型类中使用，也可以使用在方法中

泛型方法的定义：

我们在返回类型前面加上<类型参数>，不能用通配符
比如：

 public static <T>  T  A(T t){//注意写法  泛型参数要写在返回类型的前面
        return t;
    }


我们在使用时：

        String str=A("hello");//传入任意类型的参数，即可
        System.out.println(str);


注意：
     使用时这么写   A(5); //类型参数不是int，而是Integer 
             int a=A(5);//这样是自动装箱，用int型来储存返回值


泛型并不只能存在于泛型类中，也可以在一个单独的方法
---------------------------------------------------------------------------------------------------------------
另外：很多java自带的方法里面也有很多泛型方法
这里我们就讲一个之前数组工具类里面没有讲过的一个排序方法

比如现在我们想要让数据从大到小排列，我们可以使用sort的另一种形式，有比较器的参数

Arrays.sort(int arr[], Comparator<T>)

在Comparator接口里面

FunctionalInterface
public interface Comparator<T> {

 int compare(T o1, T o2);//我们只需要实现这一个抽象方法，来判断两个数的大小
}
//compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于
 
----------------------------------------------------------------
这时，我们要求从大到小排序：（没有基本类型的自定义比较，只要Number类的自定义比较）
就可以：
public static void main(String[] args) {
    Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8};//一个Integer类型的数组

    Arrays.sort(arr, new Comparator<Integer>() {//使用匿名内部类形式来实现Compare方法，会在执行排序时候被调用，不用管排序的时候是怎么用的，（其实大概率也猜到了，大于零交换位置，小于零不变），只要知道这是判断两个元素大小的方法就行
        @Override
        public int compare(Integer o1, Integer o2) {   //两个需要比较的数会在这里给出
            return o2 - o1;//如果是小到大就是 o1-o2 
              //compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于
              //这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于
        }
    });
    System.out.println(Arrays.toString(arr));//这样就可以从大到小排序
}


因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了：

public static void main(String[] args) {
    Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8};
    Arrays.sort(arr, (o1, o2) -> o2 - o1);   //使用lambda表达式，瞬间变一行，效果跟上面是一样的
    System.out.println(Arrays.toString(arr));
}
------------------------------------------------------
包括之前的数组复制方法（Arrays.copyOf()这个是数组工具类里面的，只有两个参数 ，还有一种是System.arrayCopy()五个参数）：

public static void main(String[] args) {
    String[] arr = {"AAA", "BBB", "CCC"};
    String[] newArr = Arrays.copyOf(arr, 3);  
 //这里传入的数组类型是什么，返回的类型就是什么，就得用对应的类型数组去接收，也是用到了泛型
    System.out.println(Arrays.toString(newArr));
}

因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。
———————————————————————————————————————————————————————————————————————————————
三十三、泛型界限

当我们使用泛型时，不希望使用级别过高的基本类型
这时我们就需要限定泛型的界限

**通配符可以定义上界，和下界
而泛型类和泛型方法只能定义上界

1.泛型的上界：使用关键字extends
泛型类和泛型方法都可以限定上界，但不能限定下界

像这样：
public class Score<T extends Number> {//类型参数后使用关键字extends+最顶层的类型，表示不超过这个						    类型， 这里就表示，T只能为Number或它的子类
    private  String name;
    private String id;
    private T value;


    public  Score(String name, String id,T value){

        this.name =name;
        this.id =id;
        this.value =value;
    }

    public T getValue() {
         return value ;
    }
}


同样，当我们在使用变量时，泛型通配符也支持泛型的界限

我们在创建对象时，使用通配符，也可以来限定上界，如:
Score<? extends Integer > s=new Score<>("高等数学","1561651",61) ;

-----------------------------------------------------------------------------------
2.泛型的下界：使用关键字super 
注意：下界只能通配符里使用，不能在泛型类和泛型方法里使用，对类型参数并不支持
如：
Score<? super Object > s=new Score<>("高等数学","1561651",61) ;
这里限定下界为Object，这样具体类型只能用 Object或它的父类，它的子类不能使用

这样写，不行：不支持类型参数，仅通配符可以使用
 Score<T super Object > s=new Score<>("高等数学","1561651",61)；
-------------------------------------------------------------------------------------------
3.当我们设定好上界时，直接使用类型参数，则会当作上界的类型来处理
（有没有下界都一样）
如：
public class Score<T extends Number> {
    private  String name;
    private String id;
    private T value;


    public  Score(String name, String id,T value){

        this.name =name;
        this.id =id;
        this.value =value;
    }


    public T getValue() {//这里的T被当作Number类（上界）来使用
         return value;
    }
}
只有下界时，则会当成Obejct来使用
----------------------------------------------------------------------------------------
*当我们限定上界时，类型参数就不能使用了，（下界可以）

 public  void setvalue(T value ){
        this.value =value ;
    }

当我们调用这个方法时
	 Score<? extends   Number > s=new Score<>("高等数学","1561651",61) ;
       s.setvalue(20);//输入20会报错，因为我们限定了上界，但是我们输入的20不知道是什么类型的，用强                        												     制类型转化也不行

限定了上界的引用，无法得知究竟是指向的是哪一种 子类或者是自己，所以无法使用setvalue
比如：网页你指向的是integer 但是你set了一个double怎么办，所以不可以

而限定下界，T是按object处理的，所以无所谓
——————————————————————————————————————————————————————————————————————————————————————
*三十四、类型擦除机制(待补充)

泛型信息只存在于代码编译阶段，但是在java的运行期（以及生成字节码文件后）与泛型相关的信息，会被擦除掉，专业术语叫类型擦除

实际上在Java中并不是真的有泛型类型，因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型，
比如：
有一个泛型类（抽象类形式）
public abstract class A<T> {
    abstract T test(T t);
}
编译之后：默认为Object类
public abstract class A {
    abstract Object test(Object t);
}

如果设定了上界，那么会默认为上界定义的类型
比如：
public abstract class A<T extends Number> {//限定了上界
    abstract T test(T t);
}
public abstract class A {
    abstract Number test(Number t);
}

------------------------------------------------------------------------------------------
因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用：

public static void main(String[] args) {
    Test test = new Test();    //对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型
}

只不过此时编译器会给出警告

同样的，由于类型擦除，实际上我们在使用时，编译后的代码是进行了强制类型转换的：


public static void main(String[] args) {
    A<String> a = new B();
    String  i = a.test("10");     //因为类型A只有返回值为原始类型Object的方法
}
实际上编译之后：
public static void main(String[] args) {
    A a = new B();
    String i = (String) a.test("10");   //依靠强制类型转换完成的
}


——————————————————————————————————————————————————————————————————————————————————
三十五、四大函数式子接口
函数式接口就是jdk1.8 专门用于为我们提供好的用于lambda表达式的接口，这些接口都可以直接使用lambda表达式，非常方便
------------------------------------------------------------------------------------------
1.Supplier,供给型函数式接口，这个接口是专门用于供给使用的，其中只有一个get方法用于获取需要的对象
，对象类型可以是java自带的类型或者是我们自己创建的类型
首先是个接口

@FunctionalInterface//写了这个的都是一个函数式接口，只有一个待实现的抽象方法（满足lambda表达式）
public interface Supplier<T> { //有个参数类型T,具体的类型由我们传入

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();//这个方法只要返回值是一个引用类型对象就可以
}


例子：

public class Main {
    public static void main (String[] args) {

        Supplier<Student> studentSupplier=new Supplier<Student>() {
            @Override	//接口实现   	//以匿名内部类的方式快速创建一个Supplier<T>接口对象
            public Student get() {		//参数类型为Student,重写接口里的get方法
                return new Student() ;
            }
        };
    studentSupplier.get().hello() ;//通过接口实现（对象）调用get方法，在获取一个Student对象，然							后通过这个Student对象来调用hello方法

    }

    public static class Student{//有一个方法
        public void hello(){
            System.out.println("我是学生");
        }
    }
}


结果为：
我是学生

以上通过lambda表达式可以简写为
public class Main {
    public static void main (String[] args) {

        Supplier<Student> studentSupplier=()->new Student() ;//简写为lambda表达式
        studentSupplier.get().hello() ;

    }


    public static class Student{
        public void hello(){
            System.out.println("我是学生");
        }
    }
}

因为return new Student() ;这里的返回类型和返回结果都和 Student类的构造方法一样，所以可以进一步简写为方法引用


public class Main {
    public static void main (String[] args) {

        Supplier<Student> studentSupplier=Student:: new;//方法引用

    studentSupplier.get().hello() ;

    }


    public static class Student{
        public void hello(){
            System.out.println("我是学生");
        }
    }
}

-------------------------------------------------------------------------------------------
2.Consumer消费型函数式接口：

实现accept()方法，参数传入一个对象即可，注意对象传进去后，使用了就没了

内容：

@FunctionalInterface
public interface Consumer<T> {

    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);

*使用：

public class Main {
   private static final Consumer<Student> STUDENT_CONSUMER = new Consumer<Student>(){
        @Override
        public void accept(Student student) {
            System.out.println(student +"真好吃");
        }
    };

    public static void main (String[] args) {

        Student student=new Student();
    STUDENT_CONSUMER.accept(student) ;//消耗对象

    }


    public static class Student{
        public void hello(){
            System.out.println("我是学生");
        }
    }
}

简化为lambda表达式：

public class Main {
    private static final Consumer<Student> STUDENT_CONSUMER =student ->   	  											System.out.println(student+"真好吃");

    public static void main (String[] args) {

        Student student=new Student();
    STUDENT_CONSUMER.accept(student) ;

    }


    public static class Student{
        public void hello(){
            System.out.println("我是学生");
        }
    }
}


另外：

Comsumer接口里面还有一个默认实现的方法：
andThen()方法，返回类型为 Consumer接口的对象 

default Consumer<T> andThen(Consumer<? super T> after){//参数是Comsumer接口的对象，对象的类型														为T以上
        Objects.requireNonNull(after);//判断after是不是为空,若为空，抛异常
        return (T t) -> { accept(t); after.accept(t); };//返回Consumer接口的对象，之后调用参数										after的accept()方法
    }									注意：不一定一定要这样，可以重写

例子:

public class Main {
private static final Consumer<Student> STUDENT_CONSUMER=(student)-> System.out.println(student+"真好吃");

    public static void main (String[] args) {
      Student student=new Student();
      STUDENT_CONSUMER.andThen(s->System.out.println("对吧"))
		//这里的参数名是随便写的，因为具体的类型确定了，然后用个lambda表达式，快速创建这个具体					类型的对象
              .accept(student);//这里的andThen语句表示一个后续操作，就是先调用accept,在andThen                    												里面的语句

    }

    public static class Student{

        public void hello(){
            System.out.println("我是学生");
        }
    }

}

这里结果为：
Main$Student@34ce8af7真好吃
对吧

-------------------------------------------------------------------------------------------
3.Function  像一个工厂，将一个东西扔进去，加工后丢出来

内部：（只展示了一个apply待实现抽象方法，其实还有很多默认实现的方法）
@FunctionalInterface
public interface Function<T, R> {//两个类型参数

    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);

使用：
//将Integer型的加工为String型的 
//这里实现apply为 将一个Integer 转化为字符串
private static final Function<Integer,String> INTEGER_STRING_FUNCTION=new Function<Integer, String>() {
    @Override
    public String apply(Integer integer) {//重写apply方法
        return toString();
    }
};

    public static void main (String[] args) {
        String str=INTEGER_STRING_FUNCTION.apply(10);
        System.out.println(str);
    }
}

直接化简为方法引用：
private static final Function<Integer,String> INTEGER_STRING_FUNCTION= Object::toString; 

    public static void main (String[] args) {
        String str=INTEGER_STRING_FUNCTION.apply(10);//int 10会自动装箱为Integer
        System.out.println(str);
    }
}

结果为：
10（字符串的10）

另外：里面除了后置函数andThen()  还有个前置函数 compose()
    private static final Function<Integer,String> INTEGER_STRING_FUNCTION= Object::toString;

    public static void main (String[] args) {
        String str=INTEGER_STRING_FUNCTION
                .compose(String::length)//这里的compose为前置操作，其实与endThen用法一样
			.apply("lbwnb");
        System.out.println(str);
    }
}
1.先传入lbwnb这个参数，让后变成length(这里为5)，最后再调用toString（）,将5(int) 变为5(String) 

这里的结果为：
5（字符串）

------------------------------------------------------------------------------------------
4.predicate断言型函数接口：接收一个参数，然后进行自定义判断并返回一个boolean的结果


比如：
public class Main {

    private static final Predicate<Student> STUDENT_PREDICATE=new Predicate<Student>() {
        @Override
        public boolean test(Student student) {//看是否大于等于60分
            return student.score>=60;
        }
    } ;

    public static void main (String[] args) {
        Student student=new Student();
        if(STUDENT_PREDICATE.test(student)){
            System.out.println("厉害及格了");
        } else{
            System.out.println("这都不及格你是小废物吗");
        }

    }

    public static class Student{
        int score=100;
        public void hello(){
            System.out.println("我是学生");
        }
    }

}


简化为lambda表达式：
public class Main {

    private static final Predicate<Student> STUDENT_PREDICATE=student->student.score>=60;//											这里简化为lambda表达式 
     
    public static void main (String[] args) {
        Student student=new Student();
        if(STUDENT_PREDICATE.test(student)){
            System.out.println("厉害及格了");
        } else{
            System.out.println("这都不及格你是小废物吗");
        }

    }
    public static class Student{
        int score=100;
        public void hello(){
            System.out.println("我是学生");
        }
    }

}
结果为：
厉害及格了

另外：predicate断言型函数接口里还有其他默认实现的方法
有 and or negate 
   与   或   取反


可以一起使用变为联合判断条件

———————————————————————————————————————————————————————————————————————————————
三十六、判空包装类（对于处理空指针很有用）
Optional

当我们遇到空指针问题时
比如：


public class Main {
   private static final Function<String ,String> INTEGER_STRING_FUNCTION = Objects::toString ;
    public static void main (String[] args) {

       test(null);

    }
    
    public static void test(String str){
      
        if(!str.isEmpty() ){
            System.out.println("字符串长度为"+str.length() );
        }
    }
}

会爆异常：
Exception in thread "main" java.lang.NullPointerException
	at Main.test(Main.java:21)
	at Main.main(Main.java:15)

--------------------
我们如果解决可以这样
public class Main {
   private static final Function<String ,String> INTEGER_STRING_FUNCTION = Objects::toString ;
    public static void main (String[] args) {

       test(null);

    }
    public static void test(String str){
        if(str==null)return ;//添加一个判空语句
        if(!str.isEmpty() ){
            System.out.println("字符串长度为"+str.length() );
        }
    }
}


---------------------------------
但我们可以使用Optional(判空包装类)来更优雅的解决这个空指针问题
Optional 可以帮我们跳过这个判空环节

比如：
public class Main {
    public static void main (String[] args) {
        test(“null”);

    }
   public  static void test(String str){
        Optional//会帮我们判空
                .ofNullable(str)//这样写
                .ifPresent(s->{    //ifPresent()里是一个conusmer函数式 
                   if(!s.isEmpty())
                    System.out.println(s.length());
                });
     }
}

结果为： 4

--------------------------------------------
包装之后，我们再获取时就可以优雅的处理为空的情况了
比如：

public class Main {
    public static void main (String[] args) {
        test("null");

    }
   public  static void test(String str){
      String s=Optional.ofNullable(str).get();//我们可以用get方法将传进去的对象获取出来，但是如果为空的话，会报异常
       System.out.println(s);
   }
}

---------------------------------------
如果str为空，我们就弄另外一种方案：
public class Main {
    public static void main (String[] args) {
        test(null);

    }
   public  static void test(String str){
      String s=Optional.ofNullable(str).orElse("备选方案") ;//orElse()方法
       System.out.println(s);
   }
}


结果为：备选方案

另外：
还可以转化为其他的类型
public class Main {
    public static void main (String[] args) {
        test(null);

    }
   public  static void test(String str){
      Optional<Integer> i=Optional.ofNullable(str).map(s->s.length()); //map（）里面为function函数式
      
   }
}

map方法

—————————————————————————————————————————————————————————————————————————————————————
三十七、集合类（非常重要，且使用频率十分高）
集合可以嵌套使用

1.集合与我们数学里的集合 是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素，不同的集合有不同的性质，比如，有的集合允许重复元素，有的不允许重复元素，有的集合是有序的，有的集合是无序的
 
集合类其实是为了更好地组织，管理和操作我们的数据结构（列表，集合，队列，映射等）

集合与数组的相同与不同：
相同：都是容器，都能够容纳一组元素
不同：数组大小固定，集合大小可变，并且数组存放基本类型和引用类型，集合只能存放引用类型（因为用的是泛型）

集合类由java.util包提供，包括ArryList,LinkedList,HashSet,TreeSet,HashMap等，他们是对集合这一数据结构进行实现的一种方式

总之一句话，集合类是一个类，里面由常见的数据结构，比如顺序表，链表，栈，队列，哈希表等
           

2.集合 根接口：collection接口
java中已经将我们常用的集合类型都实现好了，我们只需要直接拿来用就行了

所有的集合类最终都是实现自集合根接口
比如ArrayList类，它的祖先就是collection接口

collection接口：这个接口定义了集合类的一些基本操作，增删查改，还有很多其他的

所有的集合类，这里并不会去做笔记，因为太多了，并不能一次性全部写下，只能去看视频，不过不难，可以很快记住

———————————————————————————————————————————————————————————————————
三十八、Collection接口里面一些常用的方法

int size()//大小
boolean isEmpty()//是否为空
boolean contains(Object o)//是否包含o这个对象
Iterator<E> iterator()//生成当前集合的迭代器
Object[] toArray()//转换为Obejct类型的数组，这个是无参数的
<T> T[] toArray(T[] a)//这个有参数的，转化为对应类型的数组
boolean add(E e)//插入(尾插) 成功true，失败false，还有一个俩参数的，可以在指定位置插入
boolean remove(Object o)//移除某个对象，异常成功true，失败false
boolean containsAll(collection<?> c)//看给定的集合是不是当前集合的子集
boolean addAll(collection<?> c)//将当前集合变成当前集合与给定集合的并集
boolean removeAll(Collection<?> c)//移除给定集合种出现的所有元素，求当前集合与给定集合的差集
boolean removeIf.... //java8新增，根据给定的Predicate函数式接口进行元素移除
boolean retainAll(Collection<?> c)//在当前集合中保留给定集合中的元素，其他移除，交集
void clear()//移除所有元素
boolean equals(Object o)//判断两个集合是否相等
int hashCode()//计算哈希值
int indexOf(Object o)//返回这个对象在集合里的位置，如果没有就返回-1
...等等 还有很多方法
如:void sort(Comparetor<? super String> c)//排序，参数为Comparetor接口对象，直接用匿名内部类来实现，												 或lambda表达式
												 或方法引用
void set(E e)//修改

在其他接口里面（如：List(列表),Queue（队列）,Set（集合），Map（映射））会继承这个Collection接口，然后，有对应的集合类，来实现这些接口，这些类里面就会有很多其他的方法												  
具体的需要自己去看，了解个大概

注意：java中的集合里的两个元素（对象）是否相等看的是equals方法
就是在集合中，两个元素（对象）使用equals方法相等，那么在集合中就是相同的元素
———————————————————————————————————————————————————————————————————————————————
三十九、迭代器
遍历的方法：for  foreach语法  迭代器

所有集合类最终都继承Collection接口，而Collection接口又继承Iterable接口,（可迭代的）
在Iterable里面有iterator()方法，所以只要是继承或间接继承Iterable接口的，都会有iterator抽象方法

Iterator是迭代器类（在javaAPI里面也是一个接口）,而Iterable是一个接口
只要实现了Iterable接口的类，对象都可以调用iterator()方法来获取迭代器对象


1.在集合类里面，也可以进行遍历
可以用for 也可以用foreach语法糖
但是对于foreach ，它编译之后，并不是for 而是迭代器

迭代器用于遍历集合类，
不同的集合有不同的迭代器，并且迭代器的速度，比for while 要快


集合类对象通过调用iterator方法来快速获取当前集合的迭代器，
迭代器本身也是也是一个接口，由具体的集合实现类来根据具体情况实现（因为不同的集合类的遍历方式不同）

就是迭代器可以将多种多样不同的集合类遍历方式进行统一，只需每个集合类根据自己的情况进行对应实现就行了

Iterator类里面还有其他方法：iterator()//生成迭代器  
				  hasNext()//是否有下一个元素 
				  next()//指向下一个元素，并返回当前元素


迭代器的使用：
   List<String> list= new LinkedList<>();
        list.add("ABd");
        list.add("ABt");
        list.add("ABcg");
        list.add("ABcggr");
        Iterator<String>  iterator=list.iterator();//用迭代器类来接收一个迭代器对象
        while(iterator.hasNext() ){//hasNext是表示它有没有下一个
            System.out.println(iterator.next() );//next方法会将指针指向下一个，并且会返回当前的									元素
        }
    }

注意：
迭代器对象是一次性的，用完一次的话，如果还要使用，必须重新生成一个新的迭代器对象
（生成不能用new，只能在调用对应集合的iterator()方法）

----------------------------------------------------------------------------------------
**当然在java8里增加了一个新特性：
**集合类里，只要继承了Iterator接口，都可以使用一个foreach语法

我们可以直接使用foreach语法糖来快速遍历集合类，效果完全一样
如:
List<String> list = new LinkedList<>();
        list.add("ABd");
        list.add("ABt");
        list.add("ABcg");
        list.add("ABcggr");

 for(String s:list){
            System.out.println(s);
        }
-------------------------------------------------------------------------------------------
**forEach()方法：这个是在集合类里面的方法，也也可以用于遍历
注意：
这个forEach（）方法与我们上面 的foreach（）不同
这里forEach（）是在集合类里的方法
而foreach只是个语法糖

forEach(Consumer<? super Object> action) 参数为一个Consumer对象,为了就是消费每一个遍历的元素

forEach使用：//本质上也是迭代器
    List<String> list = new LinkedList<>();
        list.add("ABd");
        list.add("ABt");
        list.add("ABcg");
        list.add("ABcggr");
        
        list.forEach(s-> System.out.println(s));//使用lambda表达式

当然也可以简化为方法引用：

  List<String> list = new LinkedList<>();
        list.add("ABd");
        list.add("ABt");
        list.add("ABcg");
        list.add("ABcggr");

        list.forEach(System.out::println );

实际上只要是继承了迭代器接口（Iterable）的类（包括我们写的，我们写的要对接口进行实现），都可以使用foreach语法
-------------------------------------------------------------------------------------------
在来介绍一下：ListIterator接口
listIterator  这个 迭代器是针对于List集合类的强化版本，增加了更多方便的操作，因为List是有序集合，所以它支持两种方向的遍历操作，不仅可以从前往后，也可以从后往前，可以反复使用

里面还有很多新的方法
-------------------------------------------------------------------------------------------
Map映射：

单独讲一下Map(映射):可以储存键值对  一对一
Map并不是Collection的子类，而是单独的体系，但是它还是集合类

Key-Value为键值对

Map<K,V>//注意，Map有两个类型参数，一个是Key的类型，一个是Value的类型

使用：Map也有很多具体实现，如HashMap,TreeMap,LinkedHashMap
例子：
Map<String,Integer> m=new HashMap();
m.put("小明“,18);
m.put("小红”,17);//这样使用put方法就把两对键值对储存进了m里
 System.out.println(m);//打印m
结果为：{小明=19, 小红=17}  //是以这种形式被打印出来的，toString()方法的重写

注意一个键只能对应一个值，如果put多个相同键的值，那么后面会覆盖前面
-------------------------------------------------------------------------------------------
上面讲了HashMap()

这里，我们讲LinkedHashMap() 

LinkedHashMap() 与之前的LinkedHashSet()一样，是以插入顺序保存数据的，而普通的HashMap()是随机的

看源码
------------------------------------------------------------------------------------------
stream流：

Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果

使用：一般链式调用

filter(断言函数式接口) 参数为断言函数式接口，会过滤掉不符合参数的元素
distinct()  去掉重复的元素
collect() 用一个容器来收集 
sorted() 排序（可以加个比较器，来制定排序规则）
map() 参数会Function函数式接口，可以根据你实际写的条件来操作
limit(int a)//放行前面a个元素

   List<String> list=new LinkedList<>(Arrays.asList("AAA","hiash","asifajfaiosjfaj","sj","ashfhas"));//有一个list

      list=  list.stream()
                .filter(Str->Str.length()<=3 )//保留长度小于等于3的字符串
                .filter(Str->Str.charAt(0)>='A'||Str.charAt(0)<='Z')//保留首字母大写的
                .distinct()//删除重复的(用equals方法判断)
                .collect(Collectors.toList());//最后一定要用一个容器装，会返回新的对应的类型的容			//只有出现这一句的时候，上面的语句才会执行，使用的时候才会执行		     器
        System.out.println(list);
结果为：
[AAA, sj]

我们还可以创建一个随机数流：
 Random random=new Random();
        random.
                ints(0,100).//生成0-100
                limit(20).//只保留前20个
                filter(a->a>=50)//保留大于等于50的
                .forEach(a-> System.out.println(a));//依次打印

随机数流还可以支持统计
—————————————————————————————————————————————
三十九补充：

Collection工具类：

前面我们学了数学工具类Math 和 数组工具类Arrays 里面有很多方便我们的工具，
所以集合也有对应的工具类——Collections 里面也有很多可以操作集合的非常好用的工具

都是Collections.方法名来使用

max()//集合里面的最大值
min()//最小值
binarySearch()//二分搜索，注意使用之前，要前对集合排序，
sort()//排序，参数是要排序的集合，默认从小到大，你也可以自己用比较器制定排序规则
fill()//填充，用你输入的内容
emptyList()快速生成一个空的List
indexOfSubList()//找子集位置，参数为被找的子集，和找的集合
-------------------------------------------------------------------------------------------
对于：List<Integer> list=new ArrayList<>(Arrays.asList(18,666,5165,15,1,651,65,165,165,1,651,65,16) );

得益于之前学的类型擦除机制（泛型只在编译时检查，运行时不会去检查）
只有使用最原始的形态，那么我们就可以，将任意类型的集合传给list

如：List list=new ArrayList<>(Arrays.asList(1,2,3,5,6,4));//使用最元素的形态
	
list.add("AAAA");//传入不同类型的元素
System.out.println(list);

这样，里面就会有多种不同类型的元素了
结果为：[1, 2, 3, 5, 6, 4, AAAA]

当然，如果我们就是要很严格，不让一个集合里面出现不同类型的元素
我们就可以，用Collection生成一个在运行的时候也会检查的List

比如：
    List list=new ArrayList(Arrays.asList(1,2,3,5,6,4));
        list=Collections.checkedList(list,Integer.class);//生成一个检查是否为Integer类型的List
										并让原来的list等于这个新生成的       
 	list.add("AAAA");//这时候，就不能插入不同类型的元素了，会爆异常
        System.out.println(list);
-----------------------------------------------------------------------------------------
集合类对象相等判定：
我们在前面知道：

*==与为重写的equals方法都是看内存地址是否相等来判断两个对象是否相等
如果是重写了的equals方法看的是两个对象的内容是否相等，来判断两个对象是否相等 

*而在集合中，判断两个元素（对象）是否相等，用的就是重写过的equals方法，即看两者内容是否相等

*另外，特别的，在HashMap里面，我们都知道不能同时存在两个相同键，如果出现了相同键，那么后面的会覆盖前面的，那么是怎么判断两个键是否是相同的呢？
其实，既要看重写后的equals()方法，还要看hashCode()计算出来的哈希值是否相等

所以如果要判断两个对象是否相同，要用重写的equals方法，还要重写hashCode()
因为，如果两个对象的equals判断为true，那么它们的哈希值也应该相同

就是，如果要重写对象的equals方法的同时，那么也要重写hashCode方法来保证：如果equals方法相同，那么hashCode也应该相同

 String s1=new String("AAA");
      String s2=new String("AAA");
        System.out.println(s1.equals(s2) );
        System.out.println(s1.hashCode()==s2.hashCode() );
结果为：
true
true

———————————————————————————————————————————————————————————————————————————————
四十、I/O 输入输出流（等学完操作系统和计算机组成原理在回来看一遍）

注意这里的流并不是前面集合里学的Stream（流水操作）


这里的是输入输出流

jDK为我们提供了一套用于IO操作的框架，为了方便我们开发者使用，就定义了一个像水流一样的根据流的传输方向和读取单位，分为字节流(Inputstream和OutputStream) 以及字符流(Reader和Writer)的框架

*注意：
字节流一次读取一个字节，也就是一个byte的大小

而字符流就是一次读取一个字符，也就是一个char的大小（在读取纯文档的时候更加合适）
-------------------------------------------------------------------------------
绝对路径和相对路径：

绝对路径：文件完整的路径，如：C:\Users\22448\Desktop  一定是盘符开头的（windows）
相对路径：在我们代码根目录里的文件，我们可以直接写文件名 

———————————————————————————————————————————————————————
文件字节流
————————————————————————————————————————————
1.文件字节输入流：
如果你要读文件里的数据，你只能用文本文件，不能用二进制文件，因为二进制文件你只能读出它的所有字节，不能全部转化为字符串

并且，是一次性的，不能返回去再读

test.txt里内容为Hello world!

        FileInputStream stream=null;
        try {
           stream=new FileInputStream("test.txt");//创建了一个文件字节输入流，文件对象为相对路径									下的test.txt

        } catch (FileNotFoundException e) {//FileNotFoundException解决异常
            throw new RuntimeException(e);
        }finally{
            if(stream !=null){
                try{ stream.close();//用完之后一定要关闭这个流，否则会占用资源，用close方法关闭
        }catch (IOException e ){//解决close异常，一般放在finally语句块里，防止中途发生异常，不能														正常进行
                    throw new RuntimeException(e);
                }
            }
        }


这样写太复杂了（虽然保险），为了简化这种，我们有一种语法糖，来简化上面的写法

即——try-with-resource 语法

//注意这种语法只支持 实现了AutoCloseable接口的类

 try(FileInputStream inputStream =new FileInputStream("test.txt") ){//直接在try（）中定义要在完成之后释放的资源

       }catch(IOException e){
           e.printStackTrace();
       }
//无需再编写finally语句块，因为最后会指定帮我们调用close()
----------------------------------------------------------------------------------


文件字节输入流的读取：注意只有输入流，才可以读取，使用read()方法

read方法一共有 3种
int read() //最普通的，一次读取一个字节，并返回一个int值，没有内容了就返回-1
int read(byte[])//用一个byte数组取读取数据，将读到的数据(byte)储存在byte数组中
int read(byte[], int, int)



--------------------------------------------------------------------------------------
**************************************************************************************
使用read()读取：

读取数据的话，因为是字节流，所以一次读取（调用一次read()）就只会读取一个字节

读取数据：
try(FileInputStream stream =new FileInputStream("test.txt") ){
           int i=stream.read();//用read方法来读取，这样写只能一次读取一个字节
           System.out.println((char) i);//因为返回类型为int，所以要强制类型转换一下，  							用char是因为这里是字符
           int x=stream.read();//第二次读取，注意这样没有参数的read（一个字节一个字节读）没有内容							了就会返回-1，有内容就会返回读到数据的assic码
           System.out.println((char) x);
       }catch(IOException e){
            e.printStackTrace();
       }

//注意用了一个read就会读一次，并且你不能返回去



如果想要一次性全读取出来，可以使用while循环

try(FileInputStream stream =new FileInputStream("test.txt") ){
         int i;
         while((i=stream.read())!=-1){
             System.out.print((char) i );
         }
       }catch(IOException e){
            e.printStackTrace();
       }
结果为：
Hello world!

---------------------------------------------------------------------------------------
****************************************************************************************
使用：int read(byte[] b)读取

一次性会读取，byte数组长度个字节的数据，如果小于3个字节的数据了，那么有多少读多少个字节，如果没有数据了，就返回-1

当然也可以几个几个一起读出来
用read的另一种形式
int read(byte[] b)参数为byte数组 ，如果读到内容了，就会返回读到的字节的长度，读不到了就返回-1


    public class Main {
    public static  void main(String[] args) {
       try(FileInputStream stream=new FileInputStream("test.txt") ){
          byte[] bytes=new byte[3];//如果长度超过了可读的长度，那么只会有多少读多少，其他会为乱码
          while(stream.read(bytes)!=-1 ){//将读到的数据（assic形式（整数））储存到						byte数组中，并且会自动一次性读byte数组长度的数组
              System.out.println(new String(bytes));//new String（）这个构造方法可								以将byte类型数组里的元素转化为字符串
          }
       }catch(IOException e){
           e.printStackTrace();
       }
    }
}

结果为：
Hel
lo 
wor
ld!

其实这里还有点小问题：就是当文件里面的数据的字节长度不是数组长度的整数倍时，那么数组就不会完全被重新覆盖：
比如：test.txt里为hello worl
在使用上面的程序的话，就会出现：

hel
lo 
wor
lor//本来应该在l就结束的，结果仍然多了个or ，其实多了个or就是上一轮覆盖的wor的or,只是这一轮的覆盖，只把w覆盖成了l,or并没有被覆盖，所以被打印出来就是这个样子了

-------------------------------------------------------------------------

另外介绍一些方法：
stream.available()这个方法可以计算stream里还未读的字节
//小知识：utf-8编码格式里，文字是3个字节
比如：
public class Main {
    public static  void main(String[] args) {
       try(FileInputStream stream=new FileInputStream("test.txt") ){
          
           System.out.println(stream.available() );//未读时还有12个字节
           int i=stream.read();//读了一次
           System.out.println((char)i);//第一次读了H
           System.out.println(stream.available() );//还剩11个字节没读

       }catch(IOException e){
           e.printStackTrace();
       }
    }
}

结果为：
12
H
11

所以用这个就可以读一大串文字了：
比如：
test.txt里：死哦爱父母你 6sdfoe mopewf e
try(FileInputStream stream =new FileInputStream("test.txt") ){
         byte[] bytes=new byte[stream.available() ];
           stream.read(bytes);//一次性读完了所有的字节，并将内容以byte形式的数据储存到bytes里
           System.out.println(new String(bytes));将bytes里的元素转化为字符串
       }catch(IOException e){
            e.printStackTrace();
       }

//注意以上这种用法只能适用于纯文本文件（txt后缀），比如class文件就不行（以二进制形式存在）
结果为：
死哦爱父母你 6sdfoe mopewf e

----------------------------------------------------------------------------------
还有
stream.skip();会跳过任意字节数的长度
test.txt里为:hello world
比如：

try(FileInputStream stream =new FileInputStream("test.txt") ){
         byte[] bytes=new byte[stream.available() ];
           stream.skip(3);//跳过前三个字节
           System.out.println((char) stream.read() );
       }catch(IOException e){
            e.printStackTrace();
       }

结果为：
l




————————————————————————————————————————————
2.文件字节输出流：将内存里的数据储存到文件里 使用write()方法

 仍然有多种形式：
void write(int) //普通的
void write(byte[]) //将字节数组写入
void write(byte[], int off, int len)//将字符数组写入，从哪里开始，写多长

----------------------------------------------------------------------------------------
FileOutputStream stream=new FileOutputStream("test.txt") //创建了一个文件字节输出流，操作对象为test.txt文件
//注意调用这种构造方法，只能写的数据覆盖掉你操作的文件里的数据
//像要在不改变操作文件里原有的数据， 你可以使用另外一种构造方法，
即new FileOutputStream("test.txt",true);//true表示在操作文件里追加数据，
							如果不写true其实是默认为false
这样就可以在操作文件种追加传入数据，而不改变原有数据了
------------------------------------------------------------------------------------------


使用： 与文件字节输入流类似，但是它里面没有read方法，只有write方法，并且也有多种形式

**第一种int 参数形式：
write(int b)  这个形式只能一次传一个字符
将b 这个整型参数转换为字符，传入操作文件里


public class Main {
    public static  void main(String[] args) {
       try(FileOutputStream stream=new FileOutputStream("test.txt") ){
          stream.write(66);//里面需要一个int型的参数，当然还可以写入一个字符（会转换为assic）
       }catch(IOException e){
           e.printStackTrace();
       }
    }
}

这样test.txt文件里，就写入了B

**第二种：
wirte(byte[] b)，这个可以传一个字符或多个字符（字符串）
参数为一个byte数组

比如：
public class Main {
    public static  void main(String[] args) {
       try(FileOutputStream stream=new FileOutputStream("test.txt") ){
          stream.write("hello world!".getBytes() );//getBytes方法可以将字符串转为byte数组
       }catch(IOException e){				   //注意这里是hello world这个字符串对象调用了									getBytes方法
           e.printStackTrace();
       }
    }
}

以上的写法其实可以换种形式：
public class Main {
    public static  void main(String[] args) {
       try(FileOutputStream stream=new FileOutputStream("test.txt") ){
           byte[] bytes=new byte[100];//声明一个byte数组
           String str="hello world1";//一个字符串
           bytes=str.getBytes();//将字符串通过getBytes方法转换储存到byte数组里
          stream.write(bytes);//write方法，参数为byte数组
       }catch(IOException e){
           e.printStackTrace();
       }
    }
}


**第三种形式：
wirte(byte[] b, int off, int len)
参数为byte数组，开始位置，读取长度


public class Main {
    public static  void main(String[] args) {
       try(FileOutputStream stream=new FileOutputStream("test.txt") ){
									//byte数组一个元素就是一个字节
          stream.write("hello world".getBytes(),1,3 );//从byte数组的一号字节（byte b[1]）开始
       }catch(IOException e){					//读取三个字节的长度
           e.printStackTrace();
       }
    }
}


test.txt里的结果为：
ell

----------------------------------------------------------------------------------------
另外:
可能因为缓存机制
你在写数据的时候可能不是你写一点就传一点数据的，而是等你写了一部分数据之后，才会传你写的数据，
这时，如果你像要立马见到你写的数据，你可以通过flush方法（刷新），将暂时还没有传的数据，全部传进去

调用：
public class Main {
    public static  void main(String[] args) {
       try(FileOutputStream stream=new FileOutputStream("test.txt") ){

          stream.write("hello world".getBytes());
          stream.flush();//一般建议你在写完要传的数据后，就调用这个flush方法
       }catch(IOException e){
           e.printStackTrace();
       }
    }
}

----------------------------------------------------------------------------------------
另外：
如果你并不想要改变操作文件里原有的数据，而是在原有的后面追加写入， 你可以使用另外一种构造方法
new FileOutputStream("test.txt",true)

这样：
public class Main {
    public static  void main(String[] args) {
       try(FileOutputStream stream=new FileOutputStream("test.txt",true) ){//追加写入模式

          stream.write("asnsan".getBytes());
          stream.flush();
       }catch(IOException e){
           e.printStackTrace();
       }
    }
}

test.txt内容为：
hello worldasnsan //可见，并没有改变原来的数据，而是在后面追加了新传入的数据
-------------------------------------------------------------------------------------------
实战：拷贝文件

学了文件字节输入流，和文件字节输出流
我们就可以实现文件的拷贝了（文本，视频都可以）


public class Main {
    public static  void main(String[] args) {
       try(FileInputStream in=new FileInputStream("test.txt"); FileOutputStream out=new FileOutputStream("xxx.txt") ){//创建一个文件输入流（输入数据），对应的被拷贝文件为test.txt
            int i;		//创建一个文件输出流（输出数据），对应文件为xxx.txt（有没有这个文件					都一样，有的话就操作那个文件，没有就会自动帮你新建一个文件）
            while((i=in.read())!=-1){
			out.write(i);//将把test.txt里一个个读进来的字节数据，
		}						 //一个个传输到xxx.txt里

       }catch(IOException e){
           e.printStackTrace();
       }
    }
}

结果为：
xxx.txt里的内容与test.txt里完全一致

优化：
当然以上这种方式为一个一个字节拷贝，这样会很慢
我们可以使用byte数组，来多个字节一次性拷贝


可以这样：
public class Main {
    public static  void main(String[] args) {
       try(FileInputStream in=new FileInputStream("test.txt"); FileOutputStream out=new FileOutputStream("xxx.txt") ){
          byte[] bytes=new byte[1024];//创建了一个byte数组长度为1024
            while(in.read(bytes)!=-1 )//这样我们一次性可以读入1024个字节数据
                out.write(bytes);//一次可以传出1024个字节数据
       }catch(IOException e){
           e.printStackTrace();
       }
    }
}
xxx.txt里：
hello worldasnsan nullnullnull   

还可以优化：                                              
因为以上这种写法有缺陷，就是可以没有那么多个字节，就会显示null，如上面结果所示
（就是字节输入流提到的，数组没有被完全重新覆盖问题）
为了解决这个问题，我们可以进一步优化：

public class Main {
    public static  void main(String[] args) {
       try(FileInputStream in=new FileInputStream("test.txt"); FileOutputStream out=new FileOutputStream("xxx.txt") ){
          byte[] bytes=new byte[1024];
          int len;//定义一个长度变量
            while((len=in.read(bytes))!=-1 )//如果没有读完，len就会是bytes的长度
                out.write(bytes,0,len);//从0位置读到len 个长度的字节数据
       }catch(IOException e){
           e.printStackTrace();
       }
    }
}
这样就可以防止没那么多个数据，并且会很快




—————————————————————————————————————————————————————————

文件字符流：FileReader FileWriter
适合纯文本文件  最小单位为字符

字符流不同于字节流，字符流只能适用于纯文本文件，如果是其他类型的文件就不行，比如.mov
而字节流都可以（只是二进制文件不能转换为字符串）

文件字节流有两种：FileInputStream(输入read)  FileOutputStream(输出write)
文件字符流也有两种：FileReader(输入read）  FileWriter(输出write)

***如果只是拷贝文件，将文件里的数据读出来的话，我们推荐用字节流，
      但是如果你是读取纯文本文件里的内容的话，你可以使用字符流（更方便），并且字符流可以有看编码格式											  的方法（getEncoding）
----------------------------------------------------------------------------------------
3.文件字符输入流：FileReader

字节流的话只是以字节为单位来读取数据，当我们想要在既有中文又有英文的时候，一个字符一个字符的读取就很难办了，因为字节流不好控制读取的字节大小

注意：read方法，不管是字节输入流，还是，字符输入流，它们的read方法的机制是这样的：

如果是无参形式：read()，一次只会读一个字节或字符
但是如果是用数组储存的形式：read(byte[] b) read(char[] c)  read方法会将读到的数据（字节或字符）储存到对应类型的数组里，并且会返回读取到的长度（几个字节或几个字符），如果一个字节或字符都没有读到，那么会返回-1

-------------------------------------------------------------------------------------------
使用：以前面的字节流操作一样（有read write）

test.txt里：三i短d时d间d内

public class Main {//因为它FileReader FileWriter 都继承了closeable，都可以使用try-with-													resource 语法 
    public static  void main(String[] args) {
      try(FileReader reader=new FileReader("test.txt") ){//FileReader 为文件字符流
          System.out.println((char)reader.read() );//使用一次read（）方法就读一个字符
          System.out.println((char)reader.read() );
          System.out.println((char)reader.read() );
          System.out.println((char)reader.read() );

      } catch (IOException e) {
          e.printStackTrace();
      }
    }
}

结果为：
三
i
短
d
---------------------------------------------------------------------------------------
4.字符输出流：ReadWriter

当然有输入就有输出：

public class Main {
    public static  void main(String[] args) {
      try(FileWriter write=new FileWriter("test.txt") ){

        write.write("hello world ");//与字节输出流不同，字符输出流的write并不用byte数组
						//它可以直接写入字符串 或者用char数组来接收
      } catch (IOException e) {
          e.printStackTrace();
      }
    }
}


 write() 的形式有： 
   void write(int) 
   void write(char[], int off, int len)// 这两种都是可以从哪个位置开始，读几个字符结束
   void write(String, int off, int len)//  
   void write(char[])  
   void write(String)


test.txt里为：hello world

-------------------------------------------------------------------------------------------
当然与文件字节输出流一样，可以使用追加模式：

public class Main {
    public static  void main(String[] args) {
      try(FileWriter write=new FileWriter("test.txt",true) ){//true表示追加模式，在操作文件后											面追加数据而不是覆盖

        write.write("hello world ");

      } catch (IOException e) {
          e.printStackTrace();
      }
    }
}
---------------------------------------------------------------------------------------
里面还有个append方法(与write方法是一个效果)，
它与前面学的stringBuilder一样它的返回值是FileWriter对象本身，所以它可以支持链式使用

如：
public class Main {
    public static  void main(String[] args) {
      try(FileWriter write=new FileWriter("test.txt") ){
       write
               .append("hello")
               .append("world") ;
      } catch (IOException e) {
          e.printStackTrace();
      }
    }
}

test.txt里为：helloworld


其他用法与前面的文件字节流的两种差不多，可以在复习时在敲一遍
------------------------------------------------------------------------------------------

实战：
用文件字符流实现拷贝：
public class Main {
    public static  void main(String[] args) {
      try(FileReader r=new FileReader("test.txt");FileWriter w=new FileWriter("xx.txt");){
                int i;				//输出文件可以没有（会自动创建），但是输入文件一定要有
            while( (i=r.read())!=-1){//一个字符字符读，虽然慢，但是有效
                w.write(i);
            }
      } catch (IOException e) {
          e.printStackTrace();
      }
    }
}

这里的拷贝只能适用于纯文本文件

xx.txt里为 helloworld
-----------------------------------------------------------------------------------------
进阶版，加快速度：

public class Main{
    public static void main(String[] args)  {
        try(FileReader in=new FileReader("test.txt"); FileWriter out=new FileWriter("xxx.txt") ){
            char[] arr=new char[10];//进阶版，可以一次读10个，但是可能会有小问题，就是数组后面的						为被覆盖的部分，又被写入文件了，就是之前字节流那里遇到的问题
            while((in.read(arr))!=-1){
                out.write(arr);
            }
        }catch(IOException e){
            e.printStackTrace();
        }

    }
}



---------------------------------------------------------------------------------------
进一步进阶版（加快 速度和精确度），精确度是防止读不了数组的那么多长度，从而可能会在末尾多出一些									不需要的数据
								//因为读完一轮后，数组会被覆盖，但是如果你读的长								度没那么多，数组后面的元素，还是前面一轮的
								//如果你这时不用这种形式write(chars,0,len);
								//而是用write(char[] c)，那么最后未重新覆盖的内								容也会输出去，从而会在末尾多出一些不需要的数据
public class Main {
    public static  void main(String[] args) {
      try(FileWriter w=new FileWriter("xx.txt");FileReader r=new FileReader("test.txt") ){
          char[] chars=new char[3];
          int len;
          while((len=r.read(chars) )!=-1){
              w.write(chars,0,len);
          }
      } catch (IOException e) {
          e.printStackTrace();
      }
    }
}

———————————————————————————————————————————————————————————————
四十一、文件对象  File类


File类 可以用来表示一个文件或一个文件夹，它只不过是代表这个文件，但并不是这个文件本身
通过File对象，可以更好的管理和操作硬盘上的文件


File里有很多方法
下面将列举常见的：
我们先创建一个文件对象：
File file=new File("test.txt");//可以是文件或者文件夹，存不存在都无所谓，不会抛出异常
					  //文件还可以加路径
这里表示文件

---------------------------------------------------------------------------------------
以这个对象来介绍各种方法
注意调用方法会抛出个异常（可以添加throws IOException到方法签名解决）


1.file.exists(); 判断文件是否存在，true/false

2.file.getAbsolutePath(); 获取它的绝对路径，不过存不存在都会返回一个路径，不过存在的才可以点击，不												     存在的不可以点击
3.file.createNewFile()；创建新文件，如果已经有了就不创建，并返回false,如果没有就创建，并返回true

4. file.mkdir(); 创建新文件夹（目录），注意是文件夹，file代表的要注意格式没有后缀
例子： File file=new File("hello");
        System.out.println(file.mkdir());//如果没有就创建了一个新文件夹（true）,有就false

然后我们可以在hello文件夹里创建新的文件
 File file=new File("hello/test.txt");
System.out.println(file.createNewFile() );

但是要注意，如果用File file=new File("hello/test.txt")来创建新文件，
如果没有hello这个文件夹，那么就会报错

如果用File file=new File("hello/test")来创建文件夹（目录）
如果没有hello这个文件夹，不会报错，而是只是返回一个false
像这样  File file=new File("hello/test");
        System.out.println(file.mkdir());

仅仅对于这一种（文件夹里面创建文件夹），可以使用file.mkdirs();//加了 个s

 File file=new File("hello/test");
        System.out.println(file.mkdirs());一起创建
这样就解决了
---------------------------------------------------
5.file.length()；获取文件的字节数

6.file.delete();删除文件，成功true，失败false

7.file.getFreeSpace();获取剩余空间
	  File file=new File("/");//这里获取D盘的剩余空间（字节B为单位）
        System.out.println(file.getFreeSpace()/1024/1024/1024+"G");

8.file.list();获取（路径，文件夹）所有的文件
例子：File file=new File(".");//. 表示当前路径
   for(String s:file.list() ){//一般配合foreach循环
       System.out.println(s);
   }

结果为：
.idea
javalearn2.iml
out
src
test.txt


...还有其他很多方法不一一介绍了
-----------------------------------------------------------------------------------------
实战：
学了File与文件字节流和文件字符流，我们就可以实现一个待进度条的拷贝器了

public class Main {
    public static  void main(String[] args) {
    File file=new File("test.txt");
        try(FileInputStream in=new FileInputStream(file);
            FileOutputStream out=new FileOutputStream("xxx.txt") ){
            byte[] bytes=new byte[1];
            int len;
            long total=file.length(),sum=0;//定义一个文件大小的，和已经拷贝大小的变量
            while((len=in.read(bytes) )!=-1){
                out.write(bytes,0,len);
                sum+=len;
                System.out.println("文件以拷贝:"+(sum*100/total)+"%");
            }
        }catch(IOException e){
            e.printStackTrace();
        }
    }
}
结果为：
文件以拷贝:8%
文件以拷贝:16%
文件以拷贝:25%
文件以拷贝:33%
文件以拷贝:41%
文件以拷贝:50%
文件以拷贝:58%
文件以拷贝:66%
文件以拷贝:75%
文件以拷贝:83%
文件以拷贝:91%
文件以拷贝:100%

进程已结束,退出代码0

—————————————————————————————————————————————————————————————————————————
缓冲流BufferedInputStream  BufferedOutputStream
（缓存字节流的用法是与文件字节流的用法是完全一样的，只不过是两者内部的运行机制不同而已）

虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。

程序把数据保存到BufferedOutputStream缓冲区种，并没有立即保存到文件里，缓冲区中的数据会在以下情况会被保存到文件中： 1.缓冲区已满 2.flush()清空缓冲区  3.close()关闭流


虽然普通文件流读取文件数据非常便捷，但是每次读取都要从外部I/O设备去获取，由于外部I/O设备的速度一般达不到内存（缓冲区）的读取速度，所以可能造成程序反应迟钝，性能不够高，所以我们提出了缓冲流

缓冲流如它的名字一样，它可以提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果在缓存区中存在此数据，那么就不用再去请求外部设备，同样，当外部设备写入数据时，也是有缓冲区处理，而不是直接向外部设备写入（输出）
---------------------------------------------------------------------------------------
5.缓冲字节输入流：

创建：
要创建一个缓冲字节输入流，
只需要将原本的流（字节输入流）作为构造参数传入BufferedInputStream的构造方法中即可（套娃）

BufferedInputStream源码：
 public BufferedInputStream(InputStream in){//参数为InputStream的类型
        this(in, DEFAULT_BUFFER_SIZE);//缓冲区大小 8192 字节（8k）
    }


比如：BufferedInputStream stream=new BufferedInputStream(new FileInputStream("test.txt")) 

实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然也有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这种写法称为装饰者模式，在设计模式里详细介绍

当然也可以写成另外一种形式
BufferedInputStream stream=new BufferedInputStream(Files.newInputStream(Paths.get("test.txt")))
效果是一样的

你甚至可以套两层
BufferedInputStream stream=new BufferedInputStream(new BufferedInputStream(new FileInputStream("test.txt"),5)  ))//表示又两层缓冲区
----------------------------------------------------------------------------------------
使用：
其实与普通的字节流一样，他们的操作是一样的（这里只看read方法，其实其他的都是一样的）
比如：
public class Main {
    public static  void main(String[] args) {
    try(BufferedInputStream stream=new BufferedInputStream(new FileInputStream("test.txt"))  ){
        System.out.println((char)stream.read() );//直接使用read方法读取一个字节
        System.out.println((char)stream.read() );
    }catch(IOException e){
        e.printStackTrace();
    }
    }
}

注意：
使用是完全一样的，*只不过是其内部的运行机制发生了变化*，缓冲流是先从内存（缓冲区）里读取数据，当数据不够了时，才会去外部设备里读取
而普通字节流是直接从外部设备读取
---------------------------------------------------------------------------------------

I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没有了，又或者文件字节流，读了就没有了，不能返回去读）
而缓存流提供了缓存机制，一部分可以被暂时保存，就是可以倒回去再读取

BufferedInputStream支持mark()和reset()操作//标记 和返回标记

mark（int readlimit） 这里等会在仔细介绍
先举个例子：
使用：

public class Main {
    public static  void main(String[] args) {
    try(BufferedInputStream stream=new BufferedInputStream(new FileInputStream("test.txt"))  ){
        stream.mark(0);//mark会在你当前将读的位置作一个记号
        System.out.print((char)stream.read() );
        System.out.print((char)stream.read() );
        System.out.print((char)stream.read() );
        System.out.println((char)stream.read() );
        stream.reset();//调用reset后，会使得当前的读取位置回到你mark的位置
        System.out.print((char)stream.read() );
        System.out.println((char)stream.read() );
        
    }catch(IOException e){
        e.printStackTrace();
    }

    }
}
结果为：
hell
he
因为我们是在h这个位置作的记号，那么在读取四次后，我们reset返回标记点，那么我们就可以倒回去又从h开始读取

---------------------------------------------------------------------------------------
现在在来介绍mark（int readlimit）

**它的参数必须大于等于我们指定的缓冲区的大小才会生效
*（生效指的是你后面可以读多少次而不让标记失效是看你写入的参数）*

如果小于缓冲区的大小，就会以缓冲区的大小来计算，
当readlimit生效时（即大于缓冲区的大小），那么readlimit就表示你最多只能在读取 readlimit次数据的同时保证mark标记有效（或者理解为最多缓存（保存）readlimit个字节的数据），如过超过了这个最大次数，那么mark标记就会失效，如果你在使用reset就会报异常
*--------------------------------------
那么怎么看我们的缓冲区大小呢？

先看这个构造方法
BufferedInputStream stream=new BufferedInputStream(new FileInputStream("test.txt"))
这个构造方法里面其实还有一个int参数， 就代表缓冲区大小
如果不写，就默认8192字节（8k）

如果写了，像下面这样
BufferedInputStream stream=new BufferedInputStream(new FileInputStream("test.txt"),2) 
这个2表示你默认最少可以缓存2个字节的数据
----------------------------------------*
接着：
当上面我们写下stream.mark(0);时，如果参数小于你指定的缓存大小，那么它就会以你设置的缓存大小（我们例子里缓存大小默认为8192）来计算，也就是说，在之后你最多可以连续调用8192次read方法来读取数据（保存8192个字节的数据）的同时保证mark标记不失效，一旦超过mark会失效

以我们上面的例子为例

public class Main {
    public static  void main(String[] args) {
    try(BufferedInputStream stream=new BufferedInputStream(new FileInputStream("test.txt"),2)  ){//我们将最大缓存区大小设为2
        stream.mark(3);//最多只能缓存3次，下面读了4次，所以mark失效
        System.out.print((char)stream.read() );
        System.out.print((char)stream.read() );
       System.out.print((char)stream.read() );
       System.out.println((char)stream.read() );
        stream.reset();//由于mark失效，结果会报异常
        System.out.print((char)stream.read() );
        System.out.println((char)stream.read() );

    }catch(IOException e){
        e.printStackTrace();
    }

   }
}
------------------------------------------------------------------------------------
6.缓冲字节输出流
与文件字节输出流用法基本一样
public class Main {
    public static  void main(String[] args) {
try(BufferedOutputStream stream=new BufferedOutputStream(new           FileOutputStream("test.txt"),5)  ){
    
     stream.write("hello".getBytes() );
    }catch(IOException e){
        e.printStackTrace();
    }
  }
}
----------------------------------------------------------------------------------------
上面介绍了字节流的两种缓冲流用法
当然还有字符流的两种缓冲流的用法
----------------------------------------------------------------------------------------
7.缓存字符输入流：BufferedReader
定义与之前类似：BufferedReader r=new BufferedReader(new FileReader("test.txt") )
(注意：现在是缓存字符输入流了，所以构造方法里，写的应该是字符输入流FileReader)
----------------------
用法与字符输入流一样：

只不过更方便了一些：

介绍方法：
readLine()读一行字符串
public class Main{
    public static void main(String[] args)  {
        try(BufferedReader in=new BufferedReader(new FileReader("test.txt") )){
            System.out.println(in.readLine());
            System.out.println(in.readLine());
        }catch(IOException e){
            e.printStackTrace();
        }
    }
}
lines()方法
这里是之前集合里的stream
可以进行流水线操作

public class Main{
    public static void main(String[] args)  {
        try(BufferedReader in=new BufferedReader(new FileReader("test.txt") )){
            in.lines()
                    .filter(str->str.charAt(0)<='Z'&&str.charAt(0)>='A')
                    .collect(Collectors.toList());
        }catch(IOException e){
            e.printStackTrace();
        }
    }
}
markSupported()方法：
表示是否支持mark()方法
只有缓冲流的才true，其他普通的都false 
-----------------------------------------------------------------------------------------
8.缓冲字符输出流：BufferedWriter
BufferedWrite r=new BufferedWrite(new FileWrite("test.txt") )
同样也差不多

newLine()//换行

———————————————————————————————————————————————————————————————
转换流(将字节流当作字符流使用)
------------------------------------------------------------------------------------------
9.字节输出流转换字符输出流
有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？（就是读取的是字符或字符串，而我们写入的流只能是字节输出流，如果正常的话，要把字符转换为字节，才能使用，这样会很麻烦）
-----------------------------------------------------------------------------------------
我们可以这样 ：

将FileOutputStream（字节输出流）转换为 OutputStreamWriter（字符输出流），就支持以Writer(字符流)的方式输出(就是将字节流，当作字符流来使用）

public static void main(String[] args) {
    try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream("test.txt"))){  //虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入，注意里面套的是字节输出流，就是你要转换的流，外面是你要转换成的流
        writer.write("lbwnb");   //以操作Writer的样子写入OutputStream
    }catch (IOException e){
        e.printStackTrace();
    }
}

------------------------------------------------------------------------------------
10.字节输入流转换字符输入流 InputStreamReader
同样：
我们也可以将FileInputStream（字节输入流）转换为InputStreamReader(字符输入流）来使用，这样就支持Reader(字符流)的方式进行输入

public static void main(String[] args) {
    try(InputStreamReader reader = new InputStreamReader(new FileInputStream("test.txt"))){  //虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取
        System.out.println((char) reader.read());
    }catch (IOException e){
        e.printStackTrace();
    }
}
另外：
InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。(就是还可以放入对应缓冲流里面使用)
____________________________________________________________________________________
打印流

*打印流分为：字节打印流（PrintStream）和字符打印流(Printwriter)

*打印流只有输出流，并没有输入流

字节打印流继承基本的字节流（Outputstream）
字符打印流继承基本的字符流（Writer）


-------------------------------------------------------------------------------------------
打印流其实我们从一开始就在使用了：
比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流(就是继承了FilterOutputStream的流(类)的构造方法都要套娃,之前的缓冲流也是继承FilterInputStream/FilterOutputStream的，所以套娃)

但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。

------------------------------------------------------------------------------------------
11.字节打印流

我们常用的System.out也是PrintStream类型（字节打印流),不过默认是向控制台打印，我们也可以让它向文件中打印：给它一个输出流

public static void main(String[] args) {//这里创建字节打印流
    try(PrintStream out = new PrintStream(new FileOutputStream("test.txt"))){//注意套娃
        out.println("lbwnb");   //其实System.out就是一个PrintStream(字节打印流)
    }catch (IOException e){
        e.printStackTrace();
    }
}

这样文件test.txt里就有了lbwnb
----------------------------------------------------------------------------------------
println的内部机制：

我们平时使用的println方法就是PrintStream（字节打印流)中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，通过缓冲流字符输出流(BufferedWriter)将字符串转换为字符，放入缓冲区再经过字节转换字符流(OutputStreamWriter)将字符变为编码，再变为字节，最后再由字节转换字符流里面套的字节输出流输出到文件里面

所以如果我们要将字符串打印到文件里，可以不在用普通的字节输出流，而是可以直接用字节流打印流（PrintStream）

*实际上打印流里面，就是提供了各种打印的方法
-------------------------------------------------------------------------------------
（PrintStream）字节打印流的方法：

介绍几个常见的：
println() 打印后会换行，内部机制上面说了
print()  这个打印完后不会换行 
printf() 这个其实就是c里面的printf(),用法就是c里面的用法,如：printf("%d",n)，格式化打印
												%d是占位
--------------------------------------------------------------------------------------
12.字符打印流PrintWriter

注意，还是得套娃，套的是FileWriter 文件字符输出流
创建：
try(PrintWriter out=new PrintWriter(new FileWriter("test.txt") ) ){            

}catch(IOException e){
 
		e.printStackTrace();

        }

用法与字节打印流类似
-------------------------------------------------------------------------------------
13.输入流：Scanner

我们之前使用的Scanner，使用的是系统提供的输入流：

public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);//系统输入流，默认是接收控制台输入
}
当然：
我们也可以使用Scanner来扫描其他文件的输入

public static void main(String[] args) throws FileNotFoundException {
    Scanner scanner = new Scanner(new FileInputStream("test.txt")); //注意还是要套娃，
					   //这样test.txt里面的内容就会被scanner读到
}
相当于直接扫描文件中编写的内容，同样可以读取。
————————————————————————————————————————————
数据流：

数据流分为：数据输入流和数据输出流

数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式（套娃）
数据流DataOutputStream也是FilterOutputStream的子类，同样采用装饰者模式（套娃）

---------------------------------------------------------------------------------------
14.数据输入流：
最大的不同是它支持基本数据类型的直接读取：

public static void main(String[] args) {
    try (DataInputStream in = new DataInputStream(new FileInputStream("test.txt"))){
        System.out.println(in.readBoolean());   //直接将数据读取为任意基本数据类型
    }catch (IOException e) {
        e.printStackTrace();
    }
}
DataInputStream  里面也有很多方法：
FileInputStream的方法基本都有，而且多了其他的一些方法
-------------------------------------------------------------------------------------
15.数据输出流：

用于写入基本数据类型：

public static void main(String[] args) {
    try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream("output.txt"))){
        dataOutputStream.writeBoolean(false);
    }catch (IOException e) {
        e.printStackTrace();
    }
}
注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。
————————————————————————————————————————————
对象流：

既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持读取和写入呢？
答案是肯定的，因为由对象流

对象流分为：对象输入流（ObjectInputStream）和对象输出流（ObjectOutputStream）
-----------------------------------------------------------------------------------------
16.对象输入流： ObjectInputStream
ObjectInputStream 对象输入流  从文件中读取序列化引用类型对象
使用： ObjectInputStream in=new ObjectInputStream(new FileInputStream("test.txt") )；
       
	Object o=in.readObject();//会爆与反射相关的异常，要处理
注意：
ObejctInputStream 如果用readObejct()方法，那么返回值将为Obejct，
如果要赋给一个同类型对象要注意类型转换

-------------------------------------------------------------------------------------------
17.对象输出流：ObjectOutputStream

ObjectOutputStream 对象输出流， 向指定文件输出一个引用类型对象，并序列化

使用：ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream("test.txt") );

		out.WriterObject(对象);

注意对象的引用类型可以是jvm自带的也可以是自己写的类，但是前提是一定要实现Serializable接口（序列化接口）

如：
public interface Serializable {
}

例如：
public class Main {
    public static  void main(String[] args) {
    try(ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream("test.txt") );
        ObjectInputStream in=new ObjectInputStream(new FileInputStream("test.txt") ) ){
       person p=new person("小明");

       out.writeObject(p);
       person p2=(person)in.readObject();
        System.out.println(p2.name );
        
    }catch(IOException e){
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        throw new RuntimeException(e);
    }

    }
    public static class person implements Serializable {//注意一定要实现Serializable接口
        String name;
        person(String name){
            this.name =name;
        }
    }
}

*所以使用对象输出流可以保存我们的对象（很有用）
*使用对象输入流可以获取我们的对象（很有用）
----------------------------------------------------------------------------------------
但是需要注意当我们使用ObjectOutputStream对象输出流进行保存内容时
如果在我们的后续操作中，有可能会使这个类的一些结构发生了变化，而原来保存的数据只能适用于之前那个版本的类


因此我们需要一种方法来区分类的不同版本：


我们可以这样：
public static class person implements Serializable {
        private static final long serialVersionUID =123456；// 添加这么一个私有静态只读常量
        String name;							//在序列化的时候，会被自动添加这个										属性，它代表当前类的版本，我们可以		int age;							手动指定版本，每次修改一次类，那										    就手动改一次版本
        person(String name){
            this.name =name;
        }
    }

如果发生版本不匹配时，会无法反序列化为对象，就会爆异常

-----------------------------------------------------------------------------------------
另外：还有一个关键字 transient
如果你不想让某个属性序列化，你可以在其前面加一个transient

加了的话，就无法被对象输出流输出到文件中

像这样：
public class Main {
    public static  void main(String[] args) {
    try(ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream("test.txt") );
        ObjectInputStream in=new ObjectInputStream(new FileInputStream("test.txt") ) ){
        person p=new person("小明",18);
        out.writeObject(p);
        System.out.println(in.readObject());
    }catch(IOException e){
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        throw new RuntimeException(e);
    }
    }
    public static class person implements Serializable {

        String name;
        transient int age;//不让age属性序列化
        person(String name,int age){
            this.name =name;
           this.age=age;
        }
         public  String toString(){
             return "Student{"+
                     "name="+name+'\n' + "age=" +age+"  }";
         }
    }
}
结果为：
Student{name=小明
age=0  }//这里age 就没有序列化，从而没有读到
__________________________________________________________________________________
最后将所有出现的流列举以下：
文件类： File
文件字节流：FileInputStream 文件字节输入流 FileOutputStream 文件字节输出流

文件字符流：FileReader 文件字符输入流  FileWriter 文件字符输出流

缓冲流： BufferedInputStream 缓存字节输入流  BufferedOutputStream 缓存字节输出流
	  BufferedReader  缓存字符输入流     BufferedWriter  缓存字符输出流

转换流：  InputStreamReader 字节转换字符输入流  OutputStreamWriter 字节转换字符输出流

打印流：PrintStream 字节打印流  PrintWriter 字符打印流

数据流：DataInputStream 数据输入流   DataOutputStream 数据输出流

对象流：ObjectInputStream 对象输入流  ObjectOutputStream 对象输出流

注意:最后为Stream的都是字节流
     最后为Reader/Writer的都是字符流

缓冲流，转换流，打印流，数据流，对象流是要套娃的，就是在对应的构造方法里面，传入对应的子流参数



—————————————————————————————————————————————————————————————————————————————
多线程
在了解多线程之前，我们先了解一下什么是进程（操作系统里面的概念）
进程是程序执行的实体（计算机中已运行的程序），每一个进程都是一个应用程序（比如我们运行QQ，LOL，网易云音乐），都有自己的内存空间，cpu一个核心同时只能处理一个事情，当多个进程需要同时运行，cpu一般通过时间片轮调度算法，实现多个进程的同时运行

时间片轮调度算法：就是每个进程都轮流运行一下，循环
-----------------------------------------------------------------------------------------
在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位，但是，如果我希望两个任务同时进行，就必须运行连哥哥进程，由于每个进程都有自己的内存空间，进程之间的通讯就变得非常麻烦（比如要共享某些数据），而且执行不同的进程会产生上下文切换，非常耗时，那么能否实现一个进程中就能执行多个任务？
比如我们写的main就是一个程序，而一些方法就是任务
----------------------------------------------------------------------------------------
我们的main一般都是从上往下执行，上面执行完，才执行下面，那么能否再一个进程里面执行多个任务呢？
所以为了解决这个问题，提出了线程这个概念

线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是进程的内存空间），上下文切换速度也高于进程

*总的来说：在以前，进程才是程序执行的最小单位，一个任务的执行就是一个进程，如果要多个任务同时进行，那么就需要多个进程，但是每个进程有自己的内存空间，所以各个进程之间难以进行信息交互
所以我们提出了线程，线程是在进程里的，进程里面可以有很多个线程，所以多个线程都在进程这个内存空间里面，随时可以进行信息交互，而每个程序执行就会在一个单独的线程里了（所以现在线程才是程序执行的最小单位）

----------------------------------------------------------------------------------------
实际上，在java中，我们从开始，一直以来编写的都是单线程得应用程序（运行main()方法的内容），也就是说只能同时执行一个任务（无论你是调用方法，还是计算，始终都是一次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或是两个计算同时在进行，也就是异步的），就需要用到java多线程框架，实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程

—————————————————————————————————————————————
线程的创建和启动：

通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式：

Thread thread=new thread(Runnable targer); //参数是一个接口的对象
先来看以下Thread的一个有参构造：
public Thread(Runnable target){//参数是一个Runnable类型的对象，而Runnable是一个只有一个抽象方法						（run()）的接口，所以支持使用lambda表达式
						（target只有run这个方法），根据匿名内部类那里或者是lambda表					达式那里，我们知道，创建接口对象，一定要去实现它的抽象方法
} 

所以如果我们想要用这条线程来做一件任务，那么可以将这个任务实现在target的run方法里

就比如：

   Thread thread=new Thread(new Runnable() {//参数为一个Runnable接口的对象，这里使用了匿名内部类								的形式快速创建
            @Override
            public void  run() {//用我们要做的事，实现了run抽象方法
                int sum=0;
                for(int i=0;i<=10;i++){
                    sum+=i;
                }
                System.out.println("1-10的和:"+sum);
            }
        });
也可以替换为lambda表达式：
Thread thread=new Thread(() -> {
            int sum=0;
            for(int i=0;i<=10;i++){
                sum+=i;
            }
            System.out.println("1-10的和:"+sum);
        });

------------------------------------------------------------------------------------
当我们创建好一条线程之后，我们还需要调用它的start()方法来启动线程，调用了start()之后，才会开始运行线程

 public class Main{
    public static void main(String[] args)  {

        Thread thread=new Thread(() -> {//创建好了一条线程
            int sum=0;
            for(int i=0;i<=10;i++){
                sum+=i;
            }
            System.out.println("1-10的和:"+sum);
        });
        thread.start();//调用start()方法，启动线程
    }
}
结果为：
1-10的和:55
---------------------------
当然你可以个这个线程该一下名字：
public class Main{
    public static void main(String[] args)  {

        Thread thread=new Thread(() -> {//创建好了一条线程
            int sum=0;
            for(int i=0;i<=10;i++){
                sum+=i;
            }
            System.out.println("1-10的和:"+sum);
        }，"我是自定义线程");//这样这条线程的名字就叫做，自定义线程，如果不写会默认从线程0开始算
        thread.start();//调用start()方法，启动线程
    }
}

--------------------------------------------------------------------------------------
你可能觉得上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果：

public static void main(String[] args) {
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 10; i++) {
            System.out.println("我是一号线程："+i);
        }
    });
    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 15; i++) {
            System.out.println("我是二号线程："+i);
        }
    });
    t1.start();
    t2.start();
}
结果为：
我是一号线程：0
我是一号线程：1
我是一号线程：2
我是一号线程：3
我是一号线程：4
我是二号线程：0
我是二号线程：1
我是二号线程：2
我是一号线程：5
我是一号线程：6
我是一号线程：7
我是二号线程：3
我是二号线程：4
我是二号线程：5
我是二号线程：6
我是二号线程：7
我是二号线程：8
我是二号线程：9
我是二号线程：10
我是二号线程：11
我是二号线程：12
我是一号线程：8
我是一号线程：9
我是一号线程：10
我是一号线程：11
我是一号线程：12
我是一号线程：13
我是一号线程：14
我是一号线程：15
我是一号线程：16
我是一号线程：17
我是一号线程：18
我是二号线程：13
我是二号线程：14

两个线程的输出结果交替打印，所以它们是同时进行的(时间片轮流调度)
并不会等前一个线程执行完，在来执行下一个线程

其实这就是多线程的特点
-----------------------------------------------------------------------------------
注意：我们发现还有一个run方法，也能执行线程里面定义的内容，
	但是run是直接在当前线程执行(在哪个线程里面调用就在里面执行)，并不是创建一个线程执行！
	而start()才是真正创建了一个线程执行

public class Main{
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                System.out.println("我是一号线程："+i);
            }
        });
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 15; i++) {
                System.out.println("我是二号线程："+i);
            }
        });
        t1.run();
        t2.start();
    }
}
结果为：
我是一号线程：0
我是一号线程：1
我是一号线程：2
我是一号线程：3
我是一号线程：4
我是一号线程：5
我是一号线程：6
我是一号线程：7
我是一号线程：8
我是一号线程：9
我是二号线程：0
我是二号线程：1
我是二号线程：2
我是二号线程：3
我是二号线程：4
我是二号线程：5
我是二号线程：6
我是二号线程：7
我是二号线程：8
我是二号线程：9
我是二号线程：10
我是二号线程：11
我是二号线程：12
我是二号线程：13
我是二号线程：14


可以看到用run启动一号之后，是先将一号线程执行完之后，才执行的二号线程

run只是一个普通的方法，Thread的start是真正运行一个线程
---------------------------------------------------------------------------------------
https://fast.itbaima.net/2022/10/04/Srx4H8YyRWqXofc.png
**线程的执行过程及状态

新建线程----调用start()------>就绪/可执行-----获取cpu资源----->运行中------>终止
			            	^				 |    stop()
			   			|sleep()超时			 |    Error
						|IO方法返回			 |    Exception
						|获得同步锁			 |	run()/call()执行
						|收到通知			 |    结束
					  blocked  <--------------------
					   休眠	
					   waiting
					  time waiting
					（这里实际上就是卡在这里，待机的意思）

就是当创建好一个线程时，当你调用了start()，表示线程就绪，可以执行了，当线程分配到cpu资源时，线程就会开始运行，运行中可能会出现一些问题，比如IO操作(Scanner)，这时候线程就会处于休眠状态，当是输入数据之后，就会出现回到 就绪/可执行状态，等待cpu资源分配才运行，最后运行完之后就终止(或者是遇到异常之类的时候，会终止，或者用stop()强制终止(不推荐))
-----------------------------------------------------------------------------------------
休眠的例子：（休眠后面会讲到，这里了解一下）
例子：

public static void main(String[] args) throws InterruptedException {
    System.out.println("l");
    Thread.sleep(1000);    //休眠时间，以毫秒为单位，1000ms = 1s
    System.out.println("b");
    Thread.sleep(1000);
    System.out.println("w");
    Thread.sleep(1000);
    System.out.println("nb!");
}
----------------------------------------------------------------------------------------
我们也可以使用stop()方法来强行终止线程：

public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(() -> {
        Thread me = Thread.currentThread();   //获取当前线程对象
        for (int i = 0; i < 50; i++) {
            System.out.println("打印:"+i);
            if(i == 20) me.stop();  //此方法会直接终止此线程
        }
    });
    t.start();
}

虽然stop()方法能够终止此线程，但是并不是所推荐的做法（可能会导致内存无法释放等问题），有关线程中断相关问题，我们会在后面继续了解。
--------------------------------------------------------------------------------------
总结线程里面的常用方法：

start()//开始线程
currentThread()//返回当前线程对象
getName()//获取当前线程的名字
sleep() //休眠一段时间，时间作为参数传入
stop()/终止线程（不推荐使用）要通过线程对象来调用，不能通过线程类来调用

———————————————————————————————————————————————————————————
线程的休眠和中断
我们之前提到了先线程的几种状态，接下来我们将详细介绍其中的休眠和中断

-------------------------------------------------------------------------------------------
我们前面提到，当一个线程*处于运行状态*下，线程的*下一个状态会出现*以下情况：

1.当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源（时间  ，内存）。

2.当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。

3.当线程出现异常或错误 / 被stop() 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。

**这句话一定要仔细看
-----------------------------------------------------------------------------------------
而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态：

使用sleep()  //注意会有InterruptedException异常，要处理
因为可能在休眠过程中，程序会异常终止，就怕资源还没有释放就异常终止了

public static void main(String[] args) {
    Thread t = new Thread(() -> {
        try {
            System.out.println("l");
            Thread.sleep(1000);   //sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个）
            System.out.println("b");    //调用sleep后，线程会直接进入到等待状态，直到时间结束
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    t.start();
}
-----------------------------------------------------------------------------------------
通过调用sleep()方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？

public static void main(String[] args) {
    Thread t = new Thread(() -> {
        try {
            Thread.sleep(10000);  //休眠10秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    t.start();
    try {
        Thread.sleep(3000);   //休眠3秒，一定比线程t先醒来
        t.interrupt();   //调用t的interrupt方法
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
------------------------------------------------------------------------------------------
我们发现，每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法：

interrupt()，可以将线程打上中断标记，但是不会停止线程，要停止线程，需要我们利用这个中断标记，或者线程执行完，或者以别的方式来停止线程

public class Main{
    public static void main(String[] args) {
       Thread thread=new Thread(()->{
           while(true) {
               System.out.println("我还没有中断1");
               if(Thread.currentThread().isInterrupted()){//如果被打上了中断标记，就跳出循环
                   System.out.println("我被中断了，需要停止");
                   break;
               }
            }
           while(true){
               System.out.println("我还没有中断2");
               if(Thread.currentThread().isInterrupted()){如果被打上了中断标记，就跳出循环
                   System.out.println("我被中断了，需要停止");
                   break;
           }
       }
           System.out.println("我是之后的操作");
       });
       thread.start();
       try{
           Thread.sleep(1000);
           thread.interrupt();//打上中断标记
       }catch(InterruptedException e){
           e.printStackTrace();
       }
    }
}

结果为：
我还没有中断1
我还没有中断1
我还没有中断1
我还没有中断1
我还没有中断1
我还没有中断1
我还没有中断1
我被中断了，需要停止
我还没有中断2
我被中断了，需要停止
我是之后的操作

可以看到，在1秒到了之前，线程thread一直在执行，并且是死循环，不会到第二个循环里，当1秒到了后，线程thread被打上了中断标记，所以，线程thread执行的第一个循环里面if判断为true，跳出第一个循环，然后进入第二个循环，但是由于已经被打上了中断标记，所以在第二个循环里面，的第一次循环if判断为true直接跳出第二个循环，到后面的语句了

*通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，
-------------------------------------------------------------------------------------------
当然，如果我们用interrupt()打上中断标记后，我们又想让中断标记消失，我们可以使用interrupted()

注意：不要把interrupt()与interrupted()搞混了，注意后缀

interrupted()可以将中断标记复位，就是取消中断标记

public class Main{
    public static void main(String[] args) {
       Thread thread=new Thread(()->{
           while(true) {
               System.out.println("我还没有中断1");
               if(Thread.currentThread().isInterrupted()){
                   System.out.println("我被中断了，需要停止");
                break;
               }
            }
           Thread.interrupted();//取消中断标记
           while(true){
               System.out.println("我还没有中断2");
               if(Thread.currentThread().isInterrupted()){
                   System.out.println("我被中断了，需要停止");
                   break;
           }
       }
           System.out.println("我是之后的操作");
       });
       thread.start();
       try{
           Thread.sleep(100);
           thread.interrupt();
           Thread.sleep(100);
           thread.interrupt();
       }catch(InterruptedException e){
           e.printStackTrace();
       }
    }
}

结果为：
我还没有中断1
我还没有中断1
我还没有中断1
我被中断了，需要停止
我还没有中断2
我还没有中断2
我还没有中断2
我被中断了，需要停止
我是之后的操作

我们可以看到，当0.1秒前，还未被打上中断标记，那么thread就会一直在第一层循环里，
0.1秒后，thread被打上了中断标记，那么thread跳出第一轮循环，之后，thread的中断标记被复原，就不会像上面的例子一样（第二个循环执行一次），而是一直执行，当又过了0.1秒后，thread又被打上了中断标记，那么，thread就会从第二个循环里面跳出，执行后面的语句
----------------------------------------------------------------------------------------
注意几个方法的不同：
inturrept()//打上中断标记
inturrepted()//恢复，清除中断标记
isinturrepted()//当前线程是否被打上中断标记
---------------------------------------------------------------------------------------
复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？

suspend();暂停线程，
resume();恢复线程

public static void main(String[] args) {
    Thread t = new Thread(() -> {
        System.out.println("线程开始运行！");
        Thread.currentThread().suspend();   //暂停此线程
        System.out.println("线程继续运行！");
    });
    t.start();
    try {
        Thread.sleep(3000);   //休眠3秒，一定比线程t先醒来
        t.resume();   //恢复此线程
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

suspend()
resume()

虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。


——————————————————————————————————————————————————————————————————————
线程优先级：
实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，越优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。

线程的优先级一般分为以下三种：

MIN_PRIORITY 最低优先级
MAX_PRIORITY 最高优先级
NOM_PRIORITY 常规优先级
---------------------------------------------------------------------------------------
使用：
setPriority()方法来个线程设定优先级

public class Main{
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            for(int i=0;i<500;i++)
            System.out.println("线程1开始运行！");

        });

        Thread t2 = new Thread(() -> {
            for(int i=0;i<500;i++)
            System.out.println("线程2开始运行！");
        });
        t2.start();
        t.start();

        t2.setPriority(Thread.MAX_PRIORITY );
        t.setPriority(Thread.MIN_PRIORITY);
    }
}

**优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！
————————————————————————————————————————————
线程的礼让和加入：
-----------------------------------------------------------------------------------------
线程的礼让：

我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程：

public static void main(String[] args) {
    Thread t1 = new Thread(() -> {
        System.out.println("线程1开始运行！");
        for (int i = 0; i < 10; i++) {
            if(i % 5 == 0) {
                System.out.println("让位！");
                Thread.yield();//让位
            }
            System.out.println("1打印："+i);
        }
        System.out.println("线程1结束！");
    });
    Thread t2 = new Thread(() -> {
        System.out.println("线程2开始运行！");
        for (int i = 0; i < 10; i++) {
            System.out.println("2打印："+i);
        }
    });
    t1.start();
    t2.start();
}

结果为：
线程1开始运行！
让位！
线程2开始运行！
2打印：0
2打印：1
2打印：2
2打印：3
2打印：4
1打印：0
1打印：1
1打印：2
2打印：5
2打印：6
2打印：7
2打印：8
2打印：9
1打印：3
1打印：4
让位！
1打印：5
1打印：6
1打印：7
1打印：8
1打印：9
线程1结束！

**我们可以看到，当线程1让位之后，cpu会尽可能的把资源先给线程2（虽然让位之后，可能cpu的资源还是可能会给线程1），然后让线程2更快的执行

但是要注意：并不是线程1让位后，就会先进行完线程2，才会进行线程1，而且，并不是线程1让位后，线程2就会执行，也可能让位后，cpu资源还是给了线程1，线程1继续进行
------------------------------------------------------------------------------------------
线程的加入：join()

当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入：

public static void main(String[] args) {
    Thread t1 = new Thread(() -> {
        System.out.println("线程1开始运行！");
        for (int i = 0; i < 10; i++) {
            System.out.println("1打印："+i);
        }
        System.out.println("线程1结束！");
    });
    Thread t2 = new Thread(() -> {
        System.out.println("线程2开始运行！");
        for (int i = 0; i < 15; i++) {
            System.out.println("2打印："+i);
            if(i == 10){
                try {
                    System.out.println("线程1加入到此线程！");
                    t1.join();    //在i==10时，让线程1加入，先完成线程1的内容，再继续当前内容
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    });
    t1.start();
    t2.start();
}
结果为：

线程1开始运行！
线程2开始运行！
1打印：0
2打印：0
2打印：1
2打印：2
2打印：3
2打印：4
2打印：5
2打印：6
2打印：7
2打印：8
2打印：9
2打印：10
线程1加入到此线程！
1打印：1
1打印：2
1打印：3
1打印：4
1打印：5
1打印：6
1打印：7
1打印：8
1打印：9
线程1结束！
2打印：11
2打印：12
2打印：13
2打印：14

这个结果只是无数种之一，但是特点是唯一的
我们发现，线程1加入后，只要线程1还没有执行完，那么线程2就会等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。

--------------------------------------------------------------------------------
注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看：

public static void main(String[] args) {
    Thread t1 = new Thread(() -> {
        System.out.println(Thread.currentThread().getName()+"开始运行！");
        for (int i = 0; i < 50; i++) {
            System.out.println(Thread.currentThread().getName()+"打印："+i);
        }
        System.out.println("线程1结束！");
    });
    Thread t2 = new Thread(() -> {
        System.out.println("线程2开始运行！");
        for (int i = 0; i < 50; i++) {
            System.out.println("2打印："+i);
            if(i == 10){
                try {
                    System.out.println("线程1加入到此线程！");
                    t1.join();    //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    });
    t1.start();
    t2.start();
}

实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。

————————————————————————————————————————————————————————————————
线程锁和线程同步：

---------------------------------------------------------------------------------------
线程同步：

在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理：
图片：https://fast.itbaima.net/2022/10/04/ZvI8neF3tdGJwS4.png

比如我们可以来看看下面这个问题：
private static int value = 0;

public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) value++;
        System.out.println("线程1完成");
    });
    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) value++;
        System.out.println("线程2完成");
    });
    t1.start();
    t2.start();
    Thread.sleep(1000);  //主线程停止1秒，保证两个线程执行完成
    System.out.println(value);
}
结果为：
线程1完成
线程2完成
11739

为什么不是20000次呢？
因为：
实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！

注意：
线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。它类似于我们在计算机组成原理中学习的多核心处理器高速缓存机制：

图片：https://fast.itbaima.net/2022/10/04/SKlbIZyvxMnauLJ.png

*高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。

实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！

------------------------------------------------------------------------------------------
为了解决这个问题，我们提出了线程锁：

通过synchronized(同步)来创造一个线程锁

synchronized(Object o/Object.class){//参数必须为一个对象或者是一个类
	待执行语句；  //所以待执行语句，必须再有锁的情况下使用
}


首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块：
public class Main{
private static int value = 0;

public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
            synchronized (Main.class){  //使用synchronized关键字创建同步代码块
                value++;
            }
        }
        System.out.println("线程1完成");
    });
    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
            synchronized (Main.class){
                value++;
            }
        }
        System.out.println("线程2完成");
    });
    t1.start();
    t2.start();
    Thread.sleep(1000);  //主线程停止1秒，保证两个线程执行完成
    System.out.println(value);
 }
}
结果为：200000；

我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！

当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容
（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面在JUC篇视频教程中我们还会讲到乐观锁，如CAS算法）
-------------------------------------------------------------------------------------
那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？
private static int value = 0;

public static void main(String[] args) throws InterruptedException {
    Main main1 = new Main();
    Main main2 = new Main();
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
            synchronized (main1){
                value++;
            }
        }
        System.out.println("线程1完成");
    });
    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
            synchronized (main2){
                value++;
            }
        }
        System.out.println("线程2完成");
    });
    t1.start();
    t2.start();
    Thread.sleep(1000);  //主线程停止1秒，保证两个线程执行完成
    System.out.println(value);
}
结果为：
线程2完成
线程1完成
17902

所以当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。

-----------------------------------------------------------------------------------------
另外：synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：


public class Main{
private static int value = 0;

private static synchronized void add(){//这里为static  用了synchronized后，就一次只能一个线程调用
    value++;
}

public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) add();  //这里因为是static方法
        System.out.println("线程1完成");
    });
    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) add();
        System.out.println("线程2完成");
    });
    t1.start();
    t2.start();
    Thread.sleep(1000);  //主线程停止1秒，保证两个线程执行完成
    System.out.println(value);

	Thread t3 = new Thread(() -> {
        for (int i = 0; i < 10000; i++)
		synchronized(Main.class){//因为是static方法，所以要用类锁，这样才会与上面线程的锁相														    同
		 add();
		}
        System.out.println("线程3完成");
    });
  }
}

结果为：30000
----------------------------------------------
但是如果是非static：

public class Main{
private static int value = 0;

private  synchronized void add(){//非static
    value++;
}

public static void main(String[] args) throws InterruptedException {
		Main main=new main();//就需要用对应的对象来使用了
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) main.add();  //这里因为是static方法
        System.out.println("线程1完成");
    });
    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) main.add();
        System.out.println("线程2完成");
    });
    t1.start();
    t2.start();
    Thread.sleep(1000);  //主线程停止1秒，保证两个线程执行完成
    System.out.println(value);

	Thread t3 = new Thread(() -> {
        for (int i = 0; i < 10000; i++)
		synchronized(main){//因为是非static方法，所以要用对象锁，这样才会与上面线程的锁相														        同
		 main.add();
		}
        System.out.println("线程3完成");
    });
  }
}

结果为：30000

我们发现实际上效果是相同的，只不过这个锁不用你去给，
如果是静态方法，就是使用的当前类的锁，
而如果是普通成员方法，就是使用的对象锁。
通过灵活的使用synchronized就能很好地解决我们之前提到的问题了。

---------------------------------------------------------------------------------------
————————————————————————————————————————————
死锁

我们知道，当用synchronized来创建一个锁，当代码块
sychronized(锁){
	
}拿到了锁之后，括号里的任务才会执行，没有拿到会进入休眠，直到拿到了相应的锁，当拿到锁，并执行完里面的任务后，会自动释放锁

死锁在操作系统中也有所提及，他是指两个线程相互持有对方所需要的所，但是又迟迟不肯释放，导致程序卡住：


public class Main {
    public static void main(String[] args) throws InterruptedException {
        Object o1 = new Object();
        Object o2 = new Object();
        Thread t1 = new Thread(() -> {
            synchronized (o1) {
                try {
                    System.out.println("线程1拿到锁1");
                    Thread.sleep(1000);
                    System.out.println("线程1等待锁2");
                    synchronized (o2) {
                        System.out.println("线程1");
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        Thread t2 = new Thread(() -> {
            synchronized (o2) {
                try {
                    System.out.println("线程2拿到锁2");
                    Thread.sleep(1000);
                    System.out.println("线程2等待锁1");
                    synchronized (o1) {
                        System.out.println("线程2");
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t1.start();
        t2.start();
    }
}
结果为：
线程1拿到锁1
线程2拿到锁2
线程2等待锁1
线程1等待锁2

可以看到，程序并没有结束，而是一直卡在了那里，因为两者锁等待的锁，都在对方的手里，并没有释放，造成了死锁
---------------------------------------------------------------------------------------
所以，我们在编写程序时，一定要注意，不要出现死锁的情况，那么我们应该怎样来去检测死锁呢？
可以利用jstack命令来检查死锁
----------------------------------------------------------------------------------------
因此，前面说不推荐使用 suspend()去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。
----------------------------------------------------------------------------------------
————————————————————————————————————————————
wait() notify() 方法介绍：

其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()，他们其实是需要配合synchronized来使用的（实际上锁就是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了）当然，只有在同步代码块中才能使用这些方法，正常情况下会报错，我们来看看他们的作用是什么：
-----------------------------------------------------------------------------------------
wait()方法是通过一个对象来调用的:

比如 Object o1=new Object();
    o1.wait()
当然这样会出错，因为要在synchronized 语句块里，才可以正常使用


public static void main(String[] args) throws InterruptedException {
    Object o1 = new Object();
    Thread t1 = new Thread(() -> {
        synchronized (o1){
            try {
                System.out.println("开始等待");
                o1.wait();//进入等待状态并释放锁
                System.out.println("等待结束！");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
    Thread t2 = new Thread(() -> {
        synchronized (o1){
      
              for (int i = 0; i < 10; i++) {
                   System.out.println(i);   
            }
              
        }
    });
    t1.start();
    Thread.sleep(1000);
    t2.start();
}
结果为：

开始等待
0
1
2
3
4
5
6
7
8
9

线程1等待后，线程2居然开始执行了，说明线程2拿到了锁
但是呢？我们发现出现还是没有执行完，而是一直卡在了那里
这是因为，当线程1等待后，会一直处于等待状态，要被唤醒，才能继续接下来的任务
并且，就算被唤醒之后，还是要先拿到对应的锁才能继续接下来的任务

所以：
我们可以发现，对象的wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！
-----------------------------------------------------------------------------------------
notify() notifyAll() 

那么，我们怎么唤醒上面的线程1呢？
其实很简单，调用notify或者notifyAll()来唤醒就可以
注意：还是要用对象锁的对象来调用


public static void main(String[] args) throws InterruptedException {
    Object o1 = new Object();
    Thread t1 = new Thread(() -> {
        synchronized (o1){
            try {
                System.out.println("开始等待");
                o1.wait();     //进入等待状态并释放锁
                System.out.println("等待结束！");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
    Thread t2 = new Thread(() -> {
        synchronized (o1){
            System.out.println("开始唤醒！");
            o1.notify();     //唤醒处于等待状态的线程
              for (int i = 0; i < 50; i++) {
                   System.out.println(i);   
            }
              //唤醒后依然需要等待这里的锁释放之前等待的线程才能继续
        }
    });
    t1.start();
    Thread.sleep(1000);
    t2.start();
}


结果为：
开始等待
开始唤醒！
0
1
2
3
4
5
6
7
8
9
等待结束！

从结果可以看出：

程序结束了，说明线程2和线程1都执行完了，但是，我们发现，在线程1等待时，当线程2唤醒了线程1后，线程1还是，没有立即执行，而是等到线程2执行完，将锁释放后，线程1才继续执行

我们可以发现，对象的wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！

notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。

wait(long timeout)//还有一种有参数的，可以在等待多少秒后，就不再等待

wait()可以相应中断异常，就是当遇到被中断时，会抛异常
——————————————————————————————————————————————————————————————————
ThreadLocal的使用：
每一个线程都有属于自己的工作内存，那么能否只在自己的工作内存里中，创建变量仅供线程之间使用呢？

我们可以使用Threadlocal类，来创建工作内存中的变量，它将我们的变量储存在内部（只能储存一个变量），不同的线程访问到ThreadLocal对象的时候，都只能获取当前线程所属的变量

-------------------------------------------------------------------------------------
使用：
ThreadLocal是一个泛型类，要通过创建对象，通过对象来进行一些操作
比如，set() 设定我们要的变量
get()  获取当前线程所属的变量

-------------------------------------------------------------------------------------
public static void main(String[] args) throws InterruptedException {
    ThreadLocal<String> local = new ThreadLocal<>();  //注意这是一个泛型类，存储类型为我们要存放的变量类型
    Thread t1 = new Thread(() -> {
        local.set("lbwnb");   //将变量的值给予ThreadLocal
        System.out.println("变量值已设定！");
        System.out.println(local.get());   //尝试获取ThreadLocal中存放的变量
    });
    Thread t2 = new Thread(() -> {
        System.out.println(local.get());   //尝试获取ThreadLocal中存放的变量
    });
    t1.start();
    Thread.sleep(3000);    //间隔三秒
    t2.start();
}

结果为：
lbwnb
null

我们发现，线程2返回的是null，这是为什么呢？

因为，set()方法在哪个线程里调用，那么这个ThreadLocal对象创建的工作内存变量，只属于这个线程
只有在这个线程里面使用get()方法，才能得到我们设定的值，而在其他线程里面使用get()方法并不能获取我们设定在这个线程里面的值，它只能获取到我们在对应线程里面设定的值。

我们可以使用ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的线程访问到ThreadLocal对象时，都只能获取到当前线程所属的变量。

**一句话总结，在哪个线程里面设定的值，就只能在那个线程里面访问。
----------------------------------------------------------------------------------
我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容：

public static void main(String[] args) throws InterruptedException {
    ThreadLocal<String> local = new ThreadLocal<>();  //注意这是一个泛型类，存储类型为我们要存放的变量类型
    Thread t1 = new Thread(() -> {
        local.set("lbwnb");   //将变量的值给予ThreadLocal
        System.out.println("线程1变量值已设定！");
        try {
            Thread.sleep(2000);    //间隔2秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("线程1读取变量值：");
        System.out.println(local.get());   //尝试获取ThreadLocal中存放的变量
    });
    Thread t2 = new Thread(() -> {
        local.set("yyds");   //将变量的值给予ThreadLocal
        System.out.println("线程2变量值已设定！");
    });
    t1.start();
    Thread.sleep(1000);    //间隔1秒
    t2.start();
}
结果为:
线程1变量值已设定！
线程2变量值已设定！
线程1读取变量值：
lbwnb


我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。

就是说 Thread对象的set()与get() 是与线程绑定的，在哪个线程set()只能在那个线程里面get()

-----------------------------------------------------------------------------------------
注意：ThreadLocal的底层是由ThreadLocalMap来实现的，具体源码，在jvm里会讲
-------------------------------------------------------------------------------------------
我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量：

public static void main(String[] args) {
    ThreadLocal<String> local = new ThreadLocal<>();
    Thread t = new Thread(() -> {
       local.set("lbwnb");
        new Thread(() -> {
            System.out.println(local.get());
        }).start();
    });
    t.start();
}
结果为：
null
---------------------------------------------------------------------------------------
**我们可以使用InheritableThreadLocal来解决：

public class Main {
    public static void main(String[] args) {
        ThreadLocal<String> local = new InheritableThreadLocal<>();
        local.set("hello");

        Thread t = new Thread(() -> {
            
            new Thread(() -> {
                System.out.println(local.get());
            }).start();
        });
        t.start();
    }
}
结果为：
hello
可以看到主线程设定的值，被继承给了子线程

当然如果在子线程中，又重新设定值，那么就会被覆盖

public class Main {
    public static void main(String[] args) {
        ThreadLocal<String> local = new InheritableThreadLocal<>();
        local.set("hello");

        Thread t = new Thread(() -> {
            local.set("lbwnb");
            new Thread(() -> {
                System.out.println(local.get());
            }).start();
        });
        t.start();
    }
}
结果为：
lbwnb

可以看到被覆盖了
---------------------------------------------------------------------------------------
Thread还有其他的方法：

remove() 移除我们设定的值


----------------------------------------------------------------------------------------
————————————————————————————————————————————
定时器Timer类

我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用Thread.sleep()来实现：

public static void main(String[] args) {
    new TimerTask(() -> System.out.println("我是定时任务！"), 3000).start();   //创建并启动此定时任务
}

static class TimerTask{
    Runnable task;
    long time;

    public TimerTask(Runnable runnable, long time){//跟Thread一样，参数有一个Runable接口的对象
        this.task = runnable;				   //可以将我们要做的事，来实现接口里的run()
        this.time = time;
    }

    public void start(){
        new Thread(() -> {
            try {
                Thread.sleep(time);
                task.run();   //休眠后再运行,run()是在当前线程运行
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。
------------------------------------------------------------------------------------------

那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？

public static void main(String[] args) {
    new TimerLoopTask(() -> System.out.println("我是定时任务！"), 3000).start();   //创建并启动此定时任务
}

static class TimerLoopTask{
    Runnable task;
    long loopTime;

    public TimerLoopTask(Runnable runnable, long loopTime){
        this.task = runnable;
        this.loopTime = loopTime;
    }

    public void start(){
        new Thread(() -> {
            try {
                while (true){   //无限循环执行
                    Thread.sleep(loopTime);
                    task.run();   //休眠后再运行
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}

现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。
-----------------------------------------------------------------------------------------
但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务：

public class Main {
    public static void main(String[] args) {
     Timer timer=new Timer();//创建了一个定时器类
     timer.schedule(new TimerTask() {//schedule()的一种形式，参数为一个TimerTask抽象类的对象
         @Override			  //只要重写里面的run()方法，注意因为是抽象类，不能使用												lambda表达式（很可惜）
         public void run() {
             System.out.println("我是定时器");//注意是在新的线程里面执行，而不是在main线程里面
         }
     },3000，1000);//第二个参数是延时多少秒执行，第三个参数是每隔多少秒执行一次
  }
}

结果为：
我是定时器
我是定时器
我是定时器
我是定时器
我是定时器
我是定时器
我是定时器


我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程（就是 定时器里面的任务不是在主线程里面执行的，而是内部机制，重新创建了一个线程）
-----------------------------------------------------------------------------------------
还有其他方法：
通过Timer类对象来使用

cancel()//取消定时器，里面的任务不会再执行

---------------------------------------------------------------------------------------
—————————————————————————————————————————————守护线程

不要把操作系统中的守护进程和守护线程相提并论！//一个是进程一个是线程

守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。
而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程自动结束
（就是守护线程当主线程结束后会自动结束）

也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂：

线程对象.setDaemon(true)将线程设置为守护线程，注意：（必须在开始之前，中途是不允许转换的）

public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            while (true) {
                try {
                   
                        System.out.println("我是守护线程");
                        Thread.sleep(1000);
                    
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t.setDaemon(true);   //设置为守护线程（必须在开始之前，中途是不允许转换的）
        t.start();
        Thread.sleep(3000);
    }
}
结果为：
我是守护线程
我是守护线程
我是守护线程

我们可以看到，当3秒后主线程结束后，守护线程也结束了

当不是守护线程的时候
public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            
                try {
                    	while(true){
                        System.out.println("我是守护线程");
                        Thread.sleep(1000);
                   }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
          
        });
       
       t.start();
       
    }
}

结果为：
我是守护线程
我是守护线程
我是守护线程
我是守护线程
我是守护线程
我是守护线程
我是守护线程

就一直在执行，并不会因为主线程结束而结束

----------------------------------------------------------------------------------
另外，在守护线程里面创建的子线程还是守护线程

守护线程的优先级是比较低的
————————————————————————————————————————————
再谈集合类


集合类中有一个东西是Java8新增的Spliterator接口，翻译过来就是：可拆分迭代器（Splitable Iterator）和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。在集合根接口Collection中提供了一个spliterator()方法用于获取可拆分迭代器。

Collection中的spliterator()来获取可拆分迭代器
------------------------------------------------------------------------------------------
其实我们之前在讲解集合类的根接口时，就发现有这样一个方法：

default Stream<E> parallelStream() {
    return StreamSupport.stream(spliterator(), true); //parallelStream就是利用了可拆分迭代器进行多线程操作
}

并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。

----------------------------------------------------------------------------------------
public class Main {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0));
        list
                .parallelStream()    //获得并行流
                .forEach(System.out::println);//多线程遍历
    }
}
结果为：
3
9
6
0
1
2
4
5
我们发现，并不是按我们列表的顺序来遍历的，是因为里面有多个线程在一起遍历
-----------------------------------------------------------------------------------------
我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序：

public class Main {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0));
        list
                .parallelStream()    //获得并行流
                .forEachOrdered(System.out::println);//使用单线程遍历
    }
}

结果为：
1
4
5
2
9
3
6
0
-----------------------------------------------------------------------------------------
我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法：
如：
public static void main(String[] args) {
    int[] arr = new int[]{1, 4, 5, 2, 9, 3, 6, 0};
    Arrays.parallelSort(arr);   //使用多线程进行并行排序，效率更高
    System.out.println(Arrays.toString(arr));
}

更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！
-----------------------------------------------------------------------------------------

**因为多线程的加入，我们之前认识的集合类都废掉了：

public static void main(String[] args) throws InterruptedException {
    List<Integer> list = new ArrayList<>();
    new Thread(() -> {
        for (int i = 0; i < 1000; i++) {
            list.add(i);   //两个线程同时操作集合类进行插入操作
        }
    }).start();
    new Thread(() -> {
        for (int i = 1000; i < 2000; i++) {
            list.add(i);
        }
    }).start();
    Thread.sleep(2000);
    System.out.println(list.size());
}

我们发现，有些时候运气不好，得到的结果并不是2000个元素，而是：

结果为：
1989

为什么会这样呢？其实也是因为没有加线程锁的问题

因为之前的集合类，并没有考虑到多线程运行的情况，如果两个线程同时执行，那么有可能两个线程同一时间都执行同一个方法，这种情况下就很容易出问题：

public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // 当数组容量更好还差一个满的时候，这个时候两个线程同时走到了这里，因为都判断为没满，所以说没有进行扩容，但是实际上两个线程都要插入一个元素进来
    elementData[size++] = e;   //当两个线程同时在这里插入元素，直接导致越界访问
    return true;
}
---------------------------

当然，在Java早期的时候，还有一些老的集合类，这些集合类都是线程安全的：

public static void main(String[] args) throws InterruptedException {
    Vector<Integer> list = new Vector<>();   //我们可以使用Vector代替List使用
      //Hashtable<Integer, String>   也可以使用Hashtable来代替Map
    new Thread(() -> {
        for (int i = 0; i < 1000; i++) {
            list.add(i);
        }
    }).start();
    new Thread(() -> {
        for (int i = 1000; i < 2000; i++) {
            list.add(i);
        }
    }).start();

    Thread.sleep(1000);
    System.out.println(list.size());
}


因为这些集合类中的每一个方法都加了锁，所以说不会出现多线程问题，但是这些老的集合类现在已经不再使用了，我们会在JUC篇视频教程中介绍专用于并发编程的集合类。

——————————————————————————————————————————————————————————————————————


